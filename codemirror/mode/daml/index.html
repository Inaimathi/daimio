<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>CodeMirror: DAML mode</title>
    <link rel="stylesheet" href="../../lib/codemirror.css">
    <script type="text/javascript" src="http://sherpa.local/~dann/thingviz/public/js/__jquery.js"></script>
    <script type="text/javascript" src="http://sherpa.local/~dann/thingviz/public/js/__underscore.js"></script>
    <script type="text/javascript" src="http://sherpa.local/~dann/thingviz/get.php?file=node_modules/daml"></script>
    
    <script src="../../lib/codemirror.js"></script>
    <script src="daml.js"></script>
    
    <link rel="stylesheet" href="../../lib/util/simple-hint.css">
    <script src="../../lib/util/daml-hint.js"></script>
    
    <style>.CodeMirror {background: #f8f8f8;}</style>
    <link rel="stylesheet" href="../../doc/docs.css">
  </head>
  <body>
    <h1>CodeMirror: DAML mode</h1>
    <form><textarea id="code" name="code">

Some external strings. Someday, a <em>test</em> of mixed mode editing.
{mfoo foo}
{math foo x 123}
{math round value 101.01}
{math round value 101.01 x :foo}
{math round value 101.01 to 2}
{math round value 101.01 x :foo to 2}

{math round 
  value 101.01 to 2}

{:xyzzy}
{"xyzzy"}
{"xyzzy
  xyx"}

1 {2} 3
1 {/asdf asdf} 3
1 {/asdf 
    asdf} 3

Also external.

{(1 2 3)}
{(1 2 (3))}
{(1 2 {list pair value (1 2 3 4)} )}
{(1 2 {list pair value (1 2 3 4)} ) | list union}
{(1 2 
  {list pair value (1 2 3 4) 
  | list union} 
  5 6) 
| list union}

{"oh hi"}
{"oh hi, {name}"}
{"oh hi, {"name"}"}
{"oh hi, {"my good {:sir | if male else :ma'am}" | if friendly else name}"}
{(1 3 "asdf)} asdf")}

{* (1 2 3 :foo :baz)}

{story find
^ sort by :date | slice 10
^ sort by :tags
  // A comment terminator
  ^^ extract "{:foo | is in this.tags}"
  ^^ extract "{:baz | is in this.tags}"
  ^^ extract "{:xyz | is in this.tags}"
  ^__^ (^_1 ^_2 ^_3) // you could skip this line w/o change
^ extract "{(:foo :baz :xyz) | intersect this.tags | not}"
^_^ union (^_1 ^_2) | diff ^_3 | @> :lalala}

{story find by_ids #id
^ sort by :date | reverse | slice 10
^ sort by :tags | slice 20
^_^ if #sort | is like :tags | then ^_2 else ^_1
} {// note laziness -- the lifted pipelines are actually fings //}


{my set for @user_id in :profiles path :firstname value #firstname}
{my set for @user_id in :profiles path :lastname value #lastname}
{my set for @user_id in :profiles path :activity.registered value #registered}
{my set for @user_id in :profiles path :activity.plan value :cohort}
{my set for @user_id in :profiles path :signup.intent value :cohort}          

// can we curry over this, like:
{"{my set for @user_id in :profiles}"
| apply values (
    {* (:page :firstname value #firstname)}
    {* (:page :lastname value #lastname)}
    etc...
  )}

or maybe 
{process apply over fing on (:path :value) values (:firstname #firstname :lastname #lastname)}

maybe ^_^ keeps lifted sections as fings, and ^_- runs each once in 'parallel' and pushes the results into ^_1 etc. so you can use them as fings, lazily, in if/then/else etc, or use one multiple times as a template with different env state, but you can also just make a bunch of calls to e.g. the server (though if sending to a single server then just sending a single compound DAML fing is much faster)


  <=>  >=<  >=>  <=^=<  *>> >^^< [=]  ]=[

    </textarea></form>

    <script>
      var editor = CodeMirror.fromTextArea(document.getElementById("code"), {})
      
      CodeMirror.commands.autocomplete = function(cm) {CodeMirror.damlHint(cm)}    
      editor.setOption('extraKeys', {"Esc": "autocomplete"})
      editor.setOption('lineNumbers', true)
      editor.setOption('matchBrackets', true)
      
      
      
      
      // ok some new experimental stuff that doesn't really belong here at all
      
      DAML.Stacker = function(fing, when_done) {
        this.last_val = null
        this.current_index = 0
        this.size = fing.stack.length
        this.fing = fing
        this.when_done = when_done
      }
      
      DAML.Stacker.prototype.next = function(cb) {
        var self = this
        this.current_index++
        if(this.current_index == this.size) return this.when_done(this.last_val)
        
        var funitem = this.fing.stack[current_index]
        
        // ... param fiddling
        var params = funitem.params
        for(var i=0, l=params.length; i < l; i++) {
          if(typeof params[i] == 'function') params[i] = params[i]()
          // or something to that effect...
        }
        
        // async case
        if(funitem.flags.async) { 
          var new_cb = function(val) {self.last_val = val; cb(val)}
          params.push(new_cb)
          // return funitem.fun.apply(funitem.model, params)
        }
        
        // normal case
        return funitem.fun.apply(funitem.model, params)
      }
      
      DAML.Stacker.prototype.bound_next = function() {
        return this.next.bind(this)
      } 
      
      
      // er...
      // A Fing has a command stack, that's part of it.
      // the Stacker takes a fing and a cb, runs the fing, then calls the cb with its value
      // stacker needs last_val, current_index, next function... maybe that's it
      // cb will usually be another stacker's bound next fun, but at the top level it's run or something.
      
      
      
      
      
      
      
      
      
    </script>

    <p><strong>MIME types defined:</strong> <code>text/x-daml</code>.</p>

  </body>
</html>
