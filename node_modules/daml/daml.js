/*
  Initial setup:
  - create the top-level space 
  - run code in the top level space which
    - builds subspaces with their own dialects
    - builds gateways to I/O
    - connects those gateways to channels
    - connects subspaces to channels

  The basic execution process:
  - create a new Block from a string S and a Space (which has a Dialect and a Varset)
    - breaks S into components (text, pipelines, blocks)
    - recursively converts any further blocks
    - builds Pipelines from a string, dialect and varset
      - recursively builds inner pipelines and blocks
      - perform compile-time operations (escaping blocks, etc)
  - call block.execute() ... or space.execute? no, space.execute(block) always takes a param (possibly an empty one)
    
      
  
  Q: how do we keep from initially compiling subspace init blocks, since those should be compiled with their parent dialect? 
  A: don't worry about it for now -- recompile as often as needed.
  
  Q: how do we detect and activate compile-time operations? this happens in block init pipelines, including possibly our initial (top-level) block. it can also happen in regular pipelines. e.g. {begin foo | string quote}
  
  Q: how do we attach execution code to a space? A space has init code that builds it... maybe {space create} takes a block? yeah, suppose so. is that block compiled with the space's dialect? yep, that makes sense. {space create block $B dialect $D | > :MYSPACE} or something.



// NEW THOUGHTS
collects
checks
calculates
effects

gather
conditions
calculations
effects



*/ 

DAML = {}

/*
  If we make the event log a little stronger, can we use it to update local stores? 
  example: Bowser is auditing in his browser. He pulls up an audit and gets to work. This loads up all the audit data, but it also subscribes to the update channels for those _things_. Then Peach loads the same audit and makes some changes. 
  - Bowser's browser receives those events and updates the cached audit data accordingly (and hence the display).
  - Any queries to loaded objects can just hit the local cache, because it's automatically kept in sync.
 implies the local commands understand how to modify local cache based on events... hmmm.
 
 Log commands as a 3-element list: [H, M, P], with H&M as strings and P as a param map. this is canonical. also log time and user id. 
 thing: this is findable if it matches H+P.id. some commands might affect multiple things (but most don't). so... always log thing? never log thing? if the command is atomic, then the command is the bottom, not the thing. so changes on a thing are found via command search? need to list use cases. 
 
 there will be lots of 'standard form' commands, like {noun add} and {noun set-type} and {my set collection :nouns}. can we do something useful with them? 
 
 {my set} becomes a fauxcommand which includes a call to {attr set} and has user:* exec perms.
 {attr set} allows setting of a things' attributes if you have perms on that thing. (superdo can bypass, natch)
 so... how do you know what a thing's schema is? for example, given @thing, is it @thing.name or @thing.my.name?
 is it {thing set-name} or {my set attr :name}? are these formally defined somewhere or ad hoc? 
 defined: discoverable, programatically constrained, but requires locking in the schema before building
 ad hoc: flexible, friendly, but difficult to generate knowledge of thing structure -- leading to confusion and "sample querying"
 we have a fixed mechanical schema. that exists, if only in our heads. why not make it formal? could aid in migration, also, when needed.
 then anything not covered in the schema is available for attr'ing. so you can have super-friendly attrs like @thing.name, without having to specify anything (by simply *not* putting them in the formal schema).
 so a {name set} fauxcommand and the ilk for things in general? and {my set} for user-created ad hoc attrs?
 
 commands are the atomic bottom. things are underneath that. most commands change one attr on one thing at a time. but some more complex ones might change many attrs on several things at once. we want to:
 - track changes to a thing over time
 - see the system at a particular moment in time
 - rewind and fast forward through time
 - allow unlimited undoability
 complex commands are like a transaction. so maybe commands are 'simple' (one thing/attr, undo means redo prior command w/ same params (id, maybe collection for {attr set}) but different value). 
 whereas a 'complex' command requires a custom 'undo' function as part of the command definition. so the bottom command itself contains information on the collection+attr. (automated for set-* style commands)
 
 also need to allow custom events in the event log, not just commands. this is important for... i don't know what. maybe those go in a different collection. command log for commands. error log for errors. event log for other things. maybe the event log is just there for attaching listeners? but if you're using a command for firing an event then that's going to go in the command log. so you could just trigger off of that...
 (so a no-op command that goes in the command log w/ a param and allows for attaching listeners? that seems weird... but maybe with some adjustment that's the right way to go.)
  
*/

// DAML var keys match /^[-_A-Za-z0-9]+$/ but don't match /^[_-]+$/ -- i.e. at least one alphanumeric
// this way we've got lots of room for fancy options for keys, like #N
// and also we can use something like {value: 5, to: {!:__}} in our pipeline vars, where the ! means 'check the varset'

if (typeof exports !== 'undefined') {
  var _ = require('underscore')
  //     mmh = require('murmurhash3')
  // 
  // var murmurhash = mmh.murmur128HexSync
     
  if (typeof module !== 'undefined' && module.exports) {
    exports = module.exports = DAML
  }
  exports.DAML = DAML
}


DAML.FANCIES = {}
DAML.FancyGlyphs = ""
DAML.import_fancy = function(ch, obj) {
  if(typeof ch != 'string') return DAML.onerror('Fancy character must be a string')
  ch = ch[0] // only first char matters
  if(!DAML.FANCIES[ch]) {
    // TODO: check obj.eat
    DAML.FANCIES[ch] = obj
  } else {
    // TODO: ERROR
  }
  DAML.FancyGlyphs += ch
}

DAML.import_fancy(':', {
  eat: function(segment) {
    segment.type = 'String'
    segment.value = segment.value.word
    return [segment]
    // return [new DAML.Segment('String', segment.word)]
  }
})


DAML.terminators = {}
DAML.Tglyphs = ""
DAML.import_terminator = function(ch, obj) {
  if(typeof ch != 'string') return DAML.onerror('Terminator character must be a string')
  ch = ch[0] // only first char matters
  if(!DAML.terminators[ch]) DAML.terminators[ch] = []
  DAML.terminators[ch].push(obj)
  DAML.Tglyphs += ch
}

// TODO: these should do more than just return a fancy parser...

DAML.terminate = function(ch, verb, params) {
  if(!DAML.terminators[ch]) return false
  var fun, terminators = DAML.terminators[ch]
  
  for(var i=0, l=terminators.length; i < l; i++) {
    fun = terminators[i][verb]
    if(typeof fun != 'function') continue
    fun.apply(terminators[i], params)
  }
}

DAML.import_terminator('|', { // pipe
  eat: function(stream, state) {
    stream.next()
    return 'bracket'
  }
})

DAML.import_terminator('^', { // lift
  eat: function(stream, state) {
    stream.next()
    return 'bracket'
  }
})

DAML.import_terminator('/', { // comment
  eat: function(stream, state) {
    while(stream.peek() === '/') stream.next()
    state.commentLevel++
    state.stack[state.stack.length-1].onTerminate.commentLevel-- // set parent's onTerminate
    // state.stack[state.stack.length-1].onClose.commentLevel-- // set parent's onClose
    return 'comment'
  }
})


function murmurhash(key, seed) {
	var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;

	remainder = key.length & 3; // key.length % 4
	bytes = key.length - remainder;
	h1 = seed;
	c1 = 0xcc9e2d51;
	c2 = 0x1b873593;
	i = 0;

	while (i < bytes) {
	  	k1 = 
	  	  ((key.charCodeAt(i) & 0xff)) |
	  	  ((key.charCodeAt(++i) & 0xff) << 8) |
	  	  ((key.charCodeAt(++i) & 0xff) << 16) |
	  	  ((key.charCodeAt(++i) & 0xff) << 24);
		++i;

		k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
		k1 = (k1 << 15) | (k1 >>> 17);
		k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

		h1 ^= k1;
        h1 = (h1 << 13) | (h1 >>> 19);
		h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
		h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
	}

	k1 = 0;

	switch (remainder) {
		case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
		case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
		case 1: k1 ^= (key.charCodeAt(i) & 0xff);

		k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
		k1 = (k1 << 15) | (k1 >>> 17);
		k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
		h1 ^= k1;
	}

	h1 ^= key.length;

	h1 ^= h1 >>> 16;
	h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
	h1 ^= h1 >>> 13;
	h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
	h1 ^= h1 >>> 16;

	return h1 >>> 0;
}

// FIXME: STUPID HACKY RE THINGS
var ObCh = String.fromCharCode(27)
var CbCh = String.fromCharCode(7)
var ExObRe = new RegExp('{', 'g')
var ExCbRe = new RegExp('}', 'g')
var UnExObRe = new RegExp(ObCh, 'g')
var UnExCbRe = new RegExp(CbCh, 'g')

/*
  DAML.CONSTANTS = {}
  CONSTANTSFRY
  - OpenBrace
  - CloseBrace
  - OpenAngle
  - CloseAngle
*/


// DAML

DAML.ETC = {}
DAML.ABLOCKS = {}
DAML.PBLOCKS = {}
DAML.DIALECTS = {}
DAML.SPACES = {}
DAML.PIPELINES = {}
DAML.PROCESSES = {}
DAML.TYPES = {}

DAML.Parser = {}
DAML.Compiler = {}


DAML.command_open = '{'
DAML.command_closed = '}'
DAML.list_open = '('
DAML.list_closed = ')'
DAML.quote = '"'


DAML.models = {}
DAML.import_models = function(new_models) {
  _.each(new_models, function(model, model_key) {
    if(!DAML.models[model_key]) {
      DAML.models[model_key] = model
    } else {
      _.extend(DAML.models[model_key]['methods'], model['methods'])
    }
  })
}


DAML.aliases = {};
DAML.import_aliases = function(values) {
  
  // TODO: move this inside Dialects
  // THINK: this only accepts fully-formed handler/method combos, with simple params (no new ablocks). is that ideal?
  
  _.each(values, function(value, key) {
    value = DAML.Parser.get_fully_processed_segments_from_a_string_oh_goodness('{' + value + '}')
    DAML.aliases[key] = value // do some checking or something
  })
}



// DAML's type system is dynamic, weak, and latent, with implicit user-definable casting via type methods.
DAML.add_type = function(key, fun) {
  // TODO: add some type checking
  DAML.TYPES[key] = fun
};


DAML.add_type('string', function(value) {
  if(typeof value == 'string') value = value
  else if(typeof value == 'number') value = value + ""
  else if(typeof value == 'boolean') value = "" // THINK: we should only cast like this on output...
  else if(typeof value == 'object') value = JSON.stringify(value)
  else if(value && value.toString) value = value.toString()
  else value = ''
  
  return value
})

DAML.add_type('number', function(value) {
  if(typeof value == 'number') value = value
  else if(typeof value == 'string') value = +value
  else if(typeof value == 'object') value = Object.keys(value).length // THINK: this is a little weird
  else value = 0

  return value
})

DAML.add_type('integer', function(value) {
  value = DAML.TYPES['number'](value) // TODO: make a simpler way to call these
  
  return Math.round(value)
})

DAML.add_type('anything', function(value) {
  return value // THINK: what about blocks? 
})

DAML.add_type('list', function(value) {
  return DAML.toArray(value)
})

DAML.add_type('block', function(value) {
  return value // THINK: oy...
  
  // THINK: what is a block type, really?
  
  // TODO: add some checking here to ensure segment isn't barfable.
  // return DAML.blockify(segment) 
})


DAML.some_type_coercion = function() {
  // keeps the webkit debugger happy.
}


// TODO: clean up this error stuff... 

// use this to set simple errors
DAML.setError = function(error) {
  return DAML.onerror('', error)
}

// use this to report errors in low-level daml processes
DAML.onerror = function(command, error) {
  return console.log('error: ' + error, command)
}



// TODO: this should probably be a method on DAML.Space instead
DAML.run = function(daml, space) {
  if(!daml) return ""
  
  
  return DAML.SPACES.top.execute(DAML.string_to_ABlocks(daml))
  
  
  
  // return DAML.PBlock_to_Process(DAML.ABlock_to_PBlock(DAML.string_to_ABlocks(daml))).execute()
  
}


// wrap params in type funs and order them properly
// DAML.fix_params = function(method, params, pipe_count) {
//   var pobj, pkeys, pkey, failure, have_piped, type, typefun, value, 
//       values = [], clean_params = {};
//   
//   // fix params
//   var pkeys = [];
//   method.params = method.params || [];
//   for(var i=0, l=method.params.length; i < l; i++) {
//     pkeys.push(method.params[i].key);
//   }
//   
//   // NOTE: we're using a for loop here instead of _.each to reduce the call stack and closure var stack overhead.
//   for(var i=0, l=pkeys.length; i < l; i++) {
//     pkey = pkeys[i];
//     pobj = method.params[i]; 
// 
//     // add pipability
//     // TODO: soooo... this is weird. if we're looking at the params of a pipe's params and not the first param and we haven't piped yet and there's no pkey (pause for breath), then pipe. sheesh!
//     if(pipe_count >= 2 && !have_piped && !params.hasOwnProperty(pkey)) {
//       clean_params[pkey] = DAML.wrap_var('__');
//       have_piped = true;
//     } else {
//       clean_params[pkey] = params[pkey];
//     }
//     
//     // check typing
//     if(pobj.type && DAML.TYPES[pobj.type]) {
//       typefun = DAML.TYPES[pobj.type];
//     } else if(DAML.TYPES.fallback) {
//       typefun = DAML.TYPES.fallback;
//     } else {
//       typefun = function(value) {return DAML.recursive_run(value);}; // this shouldn't ever happen, but just in case.
//     }
//     
//     // compile value
//     if(clean_params[pkey] && typeof clean_params[pkey] == 'object') {
//       value = DAML.compile(clean_params[pkey], (pipe_count == 1 ? 2 : 0));
//     } else {
//       value = clean_params[pkey];
//     }
//     
//     // build value list
//     if(DAML.isNice(value)) {
//       values.push(typefun.bind(typefun, value));
//       // THINK: f.bind.apply(f, [f,2,5,3]) ?
//     }
//     else if(pobj.hasOwnProperty('fallback')) {
//       values.push(typefun.bind(typefun, pobj.fallback));
//     }
//     else if(pobj.required) {
//       failure = true; // wait until all params have been checked, in case there's more errors.
//       DAML.onerror(params, 'Missing required parameter: ' + pkey);
//     }
//     else {
//       values.push(undefined);
//     }
//   }
//   
//   return failure ? false : values;
// };


// Find some values for a variable path
DAML.resolve_path = function(path, base) {
  var words, word, value, index, temp, flat_value;
  
  if(path.indexOf(DAML.command_open) != -1) path = DAML.run(path);
  
  if(!path) return base;
  
  if(path.indexOf('.') == -1) return DAML.isNice(base[path]) ? base[path] : false;
  
  words = path.split('.');
  value = base[words.shift()]; // THINK: this is by reference...
  
  for(var i=0, l=words.length; i < l; i++) {
    word = words[i];
    
    if(!value) return value; // value == false, so return it
    
    if(typeof value == 'function') value = value();
    
    // value is scalar, but there's more words to parse... so return false.
    if((/boolean|number|string/).test(typeof value)) return false;
    
    // unpack objects // THINK: why do we need this?
    // if(!(value instanceof Array)) value = value ? [value] : []; // THINK: value === 0?
    
    // for a hash, substitute value
    if(value.hasOwnProperty(word)) {
      value = value[word];
    }
    
    // for #-X, return the Xth item from the end
    else if(word[0] == '#' && word[1] == '-' && +word.slice(2)) {
      flat_value = _.toArray(value);
      index = flat_value.length - +word.slice(2);
      value = flat_value[index];
    }
    
    // for #X, return the Xth item
    else if(word[0] == '#' && +word.slice(1)) {
      // OPT: use a for-in here and shortcut it
      flat_value = _.toArray(value);
      value = flat_value[+word.slice(1) - 1];
    }
    
    // just in case we want every value of an array moved up a slot
    else if(word == '*') {
      temp = {};
      _.each(value, function(item, key) {
        if(typeof item == 'object') {
          _.each(item, function(inner_item, inner_key) {
            if(temp[inner_key]) temp[temp.length - 1] = inner_item;
            else temp[inner_key] = inner_item;
          });
        }
      });
      value = temp ? temp : false;
    }
    
    // for AoH, build new AoH
    else if(!+word && ( // THINK: no digits... something happens with integer ids, or something.
             typeof value[Object.keys(value)[0]] == 'object' ||
             (typeof value[Object.keys(value)[0]] == 'function' &&
               typeof value[Object.keys(value)[0]]() == 'object' 
             ) // yeah, this is kind of awful. but we have to check inside the array, and it might be full of funs.
           )) { // OPT: cache the above stuff for things and stuff.
      temp = [];
      _.each(value, function(item, key) {
        if(typeof item == 'function') item = item();
        if(typeof item == 'object' && word in item) {
          if(item[word] instanceof Array) { // item[word] is AoH, so pop H's
            for(var i=0, l=item[word].length; i < l; i++) {
              temp.push(item[word][i]);
            }
          }
          else { // item[word] is H
            temp.push(item[word]);
          }            
        }
      });

      // THINK: if word is bad should we return value? null? set a warning? -- this seems to work for now, but probably requires a lot more testing / use cases.
      if(temp) value = temp;
      else value = false;
    }
    
    // just give up
    else {
      value = false;
    }
  }

  return DAML.isNice(value) ? value : false;
};



// DFS over data. apply fun whenever pattern returns true. pattern and fun each take one arg.
// NOTE: no checks for infinite recursion. call DAML.scrub_var if you need it.
DAML.recursive_walk = function(data, pattern, fun) {
  var true_pattern = false
  
  try {
    true_pattern = pattern(data) // prevents bad pattern
  } catch (e) {}
  
  
  if(true_pattern) {
    try {
      fun(data) // prevents bad fun
    } catch (e) {}
  }
  
  if(!data || typeof data != 'object') return
  
  for(var key in data) {
    if(!data.hasOwnProperty(key)) return
    DAML.recursive_walk(data[key], pattern, fun)
  }
}

// apply a function to every leaf of a tree, but generate a new copy of it as we go
DAML.recursive_leaves_copy = function(values, fun, seen) {
  if(!values || typeof values != 'object') return fun(values);

  seen = seen || []; // only YOU can prevent infinite recursion...
  if(seen.indexOf(values) !== -1) return values;
  seen.push(values);
  
  var new_values = (Array.isArray(values) ? [] : {}); // NOTE: using new_values in the parse phase (rebuilding the object each time we hit this function) causes an order-of-magnitude slowdown. zoiks, indeed.
  
  for(var key in values) {
    // this is only called from toPrimitive and deep_copy, which both want blocks
    if(DAML.isBlock(values[key])) {
      new_values[key] = fun(values[key]); // blocks are immutable
    } else if(typeof values[key] == 'object') {
      new_values[key] = DAML.recursive_leaves_copy(values[key], fun, seen);
    } else {
      new_values[key] = fun(values[key]);
    }
  }

  return new_values;
};

// apply a function to every branch of a tree
// DAML.recursive_walk = function(values, fun, seen) {
//   if(!values || typeof values != 'object') return values;
// 
//   seen = seen || []; // only YOU can prevent infinite recursion...
//   if(seen.indexOf(values) !== -1) return values;
//   seen.push(values);
//   
//   for(var key in values) {
//     var value = values[key];
//     if(typeof value == 'object') values[key] = fun(DAML.recursive_walk(value, fun, seen))
//     else values[key] = value;
//   }
//   return values;
// };

// run every function in a tree (but not funs funs return)
DAML.recursive_run = function(values, seen) {
  if(DAML.isBlock(values)) return values;
  if(typeof values == 'function') return values();
  if(!values || typeof values != 'object') return values;
  
  seen = seen || []; // only YOU can prevent infinite recursion...
  if(seen.indexOf(values) !== -1) return values;
  seen.push(values);

  var new_values = (Array.isArray(values) ? [] : {});
  
  for(var key in values) {
    var value = values[key];
    if(typeof value == 'function') {
      new_values[key] = value();
    }
    else if(typeof value == 'object') {
      new_values[key] = DAML.recursive_run(value, seen);
    }
    else {
      new_values[key] = value;
    }
  }
  return new_values;
};

// NOTE: defunctionize does a deep clone of 'values', so the value returned does not == (pointers don't match)
// THINK: there may be cases where this doesn't actually deep clone...

// run functions in a tree until there aren't any left (runs funs funs return)
DAML.defunctionize = function(values) {
  if(!values) return values; // THINK: should we purge this of nasties first?

  if(values.__nodefunc) return values;
  
  if(DAML.isBlock(values)) return values.run(); // THINK: DAML.defunctionize(values.run()) ??  
  if(typeof values == 'function') return DAML.defunctionize(values());
  if(typeof values != 'object') return values;
  
  var new_values = (Array.isArray(values) ? [] : {});

  // this is a) a little weird b) probably slow and c) probably borked in old browsers.
  Object.defineProperties(new_values, {
    __nodefunc: {
      value: true, 
      enumerable:false
    }
  });
  
  for(var key in values) {
    var value = values[key];
    if(typeof value == 'function') new_values[key] = DAML.defunctionize(value());
    else if(typeof value == 'object') new_values[key] = DAML.defunctionize(value); 
    else new_values[key] = value;
  }
  
  return new_values;
};

// walk down into a list following the path, running a callback on each end-of-path item
DAML.recursive_path_walk = function(list, path, callback, parent) {
  if(typeof list != 'object') {
    if(!path) callback(list, parent); // done walking, let's eat
    return; 
  }

  // parents for child items
  // THINK: this is inefficient and stupid...
  var this_parent = {'parent': parent};
  for(var key in list) {
    this_parent[key] = list[key];
  }

  // end of the path?
  if(!path) {
    for(var key in list) {
      callback(list[key], this_parent);
    }
    return; // out of gas, going home
  }

  var first_dot = path.indexOf('.') >= 0 ? path.indexOf('.') : path.length;
  var part = path.slice(0, first_dot); // the first bit
  path = path.slice(first_dot + 1); // the remainder

  if(part == '*') {
    for(var key in list) {
      DAML.recursive_path_walk(list[key], path, callback, this_parent);
    }
  } else {
    if(typeof list[part] != 'undefined') {
      DAML.recursive_path_walk(list[part], path, callback, this_parent);
    }
  }
};

// this is different from recursive_merge, because it replaces subvalues instead of merging
DAML.recursive_insert = function(into, keys, value) {
  // THINK: we're not blocking infinite recursion here -- is it likely to ever happen?
  if(!into || typeof into != 'object') into = {};
  
  if(typeof keys == 'string') keys = keys.split('.');
  
  if(keys.length) {
    var key = keys.shift();
    into[key] = DAML.recursive_insert(into[key], keys, value);
  }
  else {
    into = value;
  }
  
  return into;
};

DAML.isNice = function(value) {
  return !!value || value == false; // not NaN, null, or undefined
  // return (!!value || (value === value && value !== null && value !== void 0)); // not NaN, null, or undefined
};

// this converts non-iterable items into a single-element array
DAML.toArray = function(value) {
  if(Array.isArray(value)) return Array.prototype.slice.call(value);
  if(typeof value == 'object') return DAML.obj_to_array(value);
  if(value === false) return []; // hmmm...
  return [value];
};

DAML.obj_to_array = function(obj) {
  var arr = [];
  for(key in obj) {
    arr.push(obj[key]);
  }
  return arr;
};

// deep copy an internal variable (primitives and blocks only)
// NOTE: this is basically toPrimitive, for things that are already primitives. 
DAML.deep_copy = function(value) {
  if(!value || typeof value != 'object') return value; // number, string, or boolean
  if(DAML.isBlock(value)) return value; // blocks are immutable, so pass-by-ref is ok.
  return DAML.recursive_leaves_copy(value, DAML.deep_copy);
};

// copy and scrub a variable from the outside world
DAML.scrub_var = function(value) {
  try {
    return JSON.parse(JSON.stringify(value)); // this style of copying is A) the fastest deep copy on most platforms and B) gets rid of functions, which in this case is good (because we're importing from the outside world) and C) ignores prototypes (also good).
  } catch (e) {
    DAML.onerror('Your object has circular references');
    value = DAML.mean_defunctionize(value);
    if(value === null) value = false;
    return value;
  }
};

// this is like defunc, but not as nice -- it trashes funcs and snips circular refs
DAML.mean_defunctionize = function(values, seen) {
  if(!DAML.isNice(values)) return false;
  if(!values) return values;

  if(typeof values == 'function') return null;
  if(typeof values != 'object') return values; // number, string, or boolean

  seen = seen || []; // only YOU can prevent infinite recursion...
  if(seen.indexOf(values) !== -1) return null;
  seen.push(values);

  var new_values = (Array.isArray(values) ? [] : {});
  
  for(var key in values) { // list or hash: lish
    var new_value, value = values[key];
    new_value = DAML.mean_defunctionize(value, seen);
    if(new_value === null) continue;
    new_values[key] = new_value;
  }
  
  return new_values;
};



/* 
    A Block is a 'function/string'. It's an object that can behave as a regular old string or as a DAML function. 
    
    Make a new Block:
    DAML.Block.spawn({}, string);
    
    // A block is run when:
    // - coerced by a type function [does this really happen?]
    // - executed inside e.g. {process each}
    // - explicitly 'run' via {process run}
    // - end of command reached 
    //   - (== string join type coercion) [this is explicit in {string join} ... ??]
    
    when are blocks run?
    - when explicitly {process run}'d
    - {process each} as a template eg -- ie inside commands
    - at the end of a pipeline, like the trivial one {block} -- but if you do anything to it, like {block | string transform old " " new "_"} then you have to {process run} or {process unquote} it, because the transformed value is dead. 
      - also, {block | (__)} is converted into json, with the block as an unprocessed string. You'd have to explicitly use {run} on the items in the aray, or use a command that processes everything in an array -- otherwise your nested blocks just end up in string form via JSON conversion.
      - but, for reference, {block | (__) | __.#1} is run, as is {block | > :var} and {(block 2) | > :var | __.#1}
    
    Blocks contained in a list will be coerced to the block's string form, instead of being run prior to stringification. To explicitly run all blocks in a list use the 'run' command.
    
    Blocks have access to the entire environment in which they are run. They can also output directly into that environment. This makes for highly modular templates, but it can also lead to nasty surprises if that local environment isn't what you were expecting. 
    
    Importing a block into a DAML command wraps it in a protective blanket -- the only inputs available are the parameters it takes, and the only output is stdout. [make stdout better]
    
    
    
    
  our 'string -> ptree -> compiled' might not apply anymore. the string is still parsed, but what comes out of that isn't really a tree, it's a stack. and it might as well be a full-fledged function stack. what good is a ptree? if we unroll everything as we parse, we don't really need one, since our end goal isn't a tree but a stack.
  is this reasonable? it's going to require a lot of fiddly array splicing. would it be better to make a tree and then flatten that?
  i currently see no disadvantage in pushing the flattening straight into the parse return. lets do that for now.
    
    
*/



/*


  NEW PARSING STUFF HERE!!!!!!
  


  An ABlock looks like {
    head: ...
    body: ...
  }
  head is either an array of Segments or a falsy value
  body is either an array of strings and ABlocks or a falsy value

  head is an array of Segment objects, which look like {
    type: ""
    value: ...
    params: {}
    ins: {}
    outs: []
  }
  type is Number, String, List, Command, Alias, or Block
  value is {Handler: "", Method: ""} for command, raw value otherwise
  params is an 1D key/value for Command or Alias with "!" as implicit key and NULL for referenced values
  ins' keys are param keys, values are previous outs
  outs are labels for partial products
  
  
  
  ---------> so... the ABlock head is an Apipeline, but the Apipeline is really just an array of Asegments. do we need Apipelines are all? NOPE.
  
  
  
  A PBlock looks like {
    Pipeline: ...
    Body: ...
  }
  Head is a Pipeline or a falsy value
  Body is an array of strings and PBlocks or a falsy value
  
  A Pipeline is a stack of PSegments (yuck) like {
    method: ...
    value: ...
    params: {}
    ins: {}
    outs: []
  }
  with either method (pointer) or value but not both
    
  
*/





// TODO: DELETE ME
DAML.isBlock = function() {
  return false
}
DAML.Vstack = [{}]
DAML.VARS = {}



// TODO: make this string->ABlock into a (n un) Renderer
// THINK: we also need to split out a RendLet somehow from the original string...
DAML.string_to_ABlocks = function(string) {
  return DAML.string_to_ABlocks_and_RendLet(string)[0]
}

DAML.string_to_ABlocks_and_RendLet = function(string) {
  var P = DAML.Parser
    , RL = 12345
    , AB = P.prepend_in_ABlock(
             P.split_string(string)
              .map(P.create_ABlocks)
              .reduce(function(a,b) {return a.concat(b)}, []) 
           )
           
           
  /*
    WAT
  
    f = Array.prototype.concat
    > function concat() { [native code] }
    f(1)
    > [Window, 1]
    Array.prototype.concat(1)
    > [1]
    f === Array.prototype.concat
    > true


    WAT
  
    works: .reduce(function(z,a) {return Array.prototype.concat(z,a)}) 
    no works: .reduce(Array.prototype.concat)
  
  */

  return [AB, RL]
}

// DAML.ABlock_to_PBlock = function(ABlock, space, parent) {
//   if(!ABlock.head && !ABlock.body)
//     return DAML.Compiler.empty_PBlock()
//   
//   return new DAML.PBlock(ABlock, space, parent)
// }
// 
// // TODO: this should involve DAML.Renderers.Executable(PBlock, Rendlet) or something
// // DAML.PBlock_to_Process = function(PBlock) {
// //   return new DAML.Process(PBlock)
// // }
// 
// DAML.Compiler.empty_PBlock = function() {
//   return new DAML.PBlock(DAML.empty_ABlock())
// }


// DAML.load_ABlocks = function(ablocks) {
//   ablocks.map(function(ablock) {
//     DAML.ABLOCKS[ablock[id]] = ablock
//   })
// }

DAML.empty_ABlock = function() {
  return new DAML.ABlock()
}

DAML.Parser.prepend_in_ABlock = function(ablocks) {
  var new_ablock = new DAML.ABlock(false, ablocks)
    , no_strings = []
  
  ablocks = ablocks || []
  no_strings = ablocks.filter(function(item) {return typeof item != 'string'})
  
  return [new_ablock].concat(no_strings) // OPT
  
    // 
    // var first = ablocks ? ablocks[0] : {}
    // 
    // if(!first.id) {
    //   // THINK: this is a hacky way of deciding between a set of ablocks and a set of strings/blockrefs. put this somewhere else and make it better!
    //   return [new DAML.ABlock(false, ablocks)]
    // }
    // 
    // return [new DAML.ABlock(false, ablocks)].concat(ablocks) // OPT
}

DAML.Parser.split_string = function(string) {
  var chunks = []
    , chunk = ""
  
  while(chunk = DAML.Parser.get_next_thing(string)) {
    string = string.slice(chunk.length)

    if(chunk[0] == DAML.command_open)
      chunk = {block: chunk}
      
    chunks.push(chunk)
  }
  
  /* "asdf {begin foo | string reverse} la{$x}la {end foo}{lkdjfj} askdfj" ==>
       ["asdf ", 
        {block: "{begin foo | string reverse} la{$x}la {end foo}"}, 
        {block: "{lkdjfj}"}, 
        " askdfj"]
  */
  

  return chunks
}

DAML.Parser.get_next_thing = function(string, ignore_begin) {
  var first_open, next_open, next_closed
  
  first_open = next_open = next_closed = string.indexOf(DAML.command_open);
  
  if(first_open == -1) return string  // no DAML here
  if(first_open > 0) return string.slice(0, first_open)  // trim non-DAML head

  do {
    next_open = string.indexOf(DAML.command_open, next_open + 1)
    next_closed = string.indexOf(DAML.command_closed, next_closed) + 1
  } while(next_closed && next_open != -1 && next_closed > next_open)

  // TODO: add a different mode that returns the unfulfilled model / method etc (for autocomplete)
  if(!next_closed) {
    DAML.onerror("No closing brace for '" + string + "'")
    return string
  }

  if(ignore_begin || string.slice(0,7) != DAML.command_open + 'begin ')
    return string.slice(0, next_closed)  // not a block

  var block_name = string.match(/^\{begin (\w+)/)
  if(!block_name) {
    // FIXME: handle this situation better
    DAML.onerror(string, 'Something weird happened')
    return string
  }
  block_name = block_name[1];
  
  var end_tag = DAML.command_open + 'end ' + block_name + DAML.command_closed
    , end_begin = string.indexOf(end_tag)
    , end_end = end_begin + end_tag.length;
    
  if(!end_begin) {
    // FIXME: handle this situation better
    DAML.onerror(string, "No end tag for block '" + block_name + "'");
    return string;
  }
  
  return string.slice(0, end_end);
}

DAML.Parser.create_ABlocks = function(basic_block) {
  if(typeof basic_block == 'string') 
    return [basic_block] // wrapped so we can reduce over both strings and sets of blocks
  
  var block_string = basic_block.block
    , segments
    , new_ablocks
  
  // single pipeline
  if(block_string.slice(0,7) != '{begin ') {
    segments = DAML.Parser.get_fully_processed_segments_from_a_string_oh_goodness(block_string)
    new_ablocks = DAML.Parser.get_ablocks_from_segments(segments)
    return [new DAML.ABlock(segments)].concat(new_ablocks)
  }
  
  // a named block
  var begin_match = block_string.match(/^\{begin (.?\w+)/)
    , block_name = begin_match[1]
    , end_regex = RegExp('\{end ' + block_name + '\}$')
    , end_match = block_string.match(end_regex)
    , body_string = ''
    , ablocks = []
    
  if(!end_match) {
    DAML.setError("No end block found")
    return DAML.empty_ABlock() // THINK: what happens here?
  }
  
  // replace 'begin foo' with the first ABlock ref and run pipeline
  var head = DAML.Parser.get_next_thing(block_string, true)
  
  // get an array of ABlocks from the body string
  body_string = block_string.slice(head.length, -1 * end_match[0].length)
  ablocks = DAML.string_to_ABlocks(body_string)
                .map(function(block) {block.adjunct = true; return block})
    
  segments = DAML.Parser.get_fully_processed_segments_from_a_string_oh_goodness(head, ablocks[0].id)
  new_ablocks = DAML.Parser.get_ablocks_from_segments(segments)
                    .map(function(block) {block.adjunct = true; return block}) // THINK: do we need this???
  
  // return pipeline and ABlock array
  return [new DAML.ABlock(segments)].concat(ablocks).concat(new_ablocks)
}

DAML.Parser.get_ablocks_from_segments = function(segments) {
  var blocks = []
  
  for(var i=0, l=segments.length; i < l; i++) {
    if(!segments[i].blocks) continue
    blocks = blocks.concat(segments[i].blocks)
    delete segments[i].blocks
  }
  
  blocks.map(function(block) {block.adjunct = true; return block})
  
  return blocks
}

DAML.Parser.get_fully_processed_segments_from_a_string_oh_goodness = function(string, replacement_for_begin) {
  var P = DAML.Parser
    , segments = DAML.Parser.pipeline_string_to_segments(string)
  
  if(!segments.length)
    return segments
  
  if(replacement_for_begin) {
    if(segments[0].type == 'Begin') {
      segments[0] = new DAML.Segment('Block', replacement_for_begin)
    }
  }

  for(var key in DAML.TRANSFORMERS) {
    segments = DAML.mungeLR(segments, DAML.TRANSFORMERS[key])
  }

  return segments
}

DAML.Parser.pipeline_string_to_segments = function(pipeline_string) {
  var output = []
    , P = DAML.Parser
  
  if(typeof pipeline_string != 'string') 
    return pipeline_string || []
  
  pipeline_string = pipeline_string.slice(1,-1)
  
  return P.split_on_terminators(pipeline_string)
          .map(function(segment) {return P.try_all_the_things(segment, true)})
          .reduce(function(a,b) {return a.concat(b)}, []) 
            
  // output.unshift({Terminator: DAML.command_open})
  // output.push({Terminator: DAML.command_closed})
  
  /* 
    {12 | math add to 5 | add 3}  ==>  
      [{Number: 12}, 
       {Handler: 'math', Method: 'add', Params: {to: {Number: 5}}}, 
       {Alias: 'add', Params: {"!": {Number: 3}}}]
  */
  
}



/// TRY THINGS ///
/// NOTE: this always returns an ARRAY of segments!
DAML.Parser.try_all_the_things = function(segment_string, inside_pipeline) {
  var P = DAML.Parser
    , things = [ P.try_number
               , P.try_string
               , P.try_list
               , P.try_begin
               , P.try_fancy
               , P.try_pipeline]
               
  if(inside_pipeline)
    things.push(P.try_command) // inside a pipeline we accept unwrapped commands; in a param slot (e.g. lists) we don't.
  
  things.push(P.catch_all) // this has to go last. it catches symbolic aliases and other weird stuff.
  
  if(segment_string.trim)
    segment_string = segment_string.trim() // THINK: is there a better place for this?
               
  for(var i=0, l=things.length; i < l; i++) {
    if(typeof segment_string != 'string')
      return Array.isArray(segment_string) ? segment_string : [segment_string]
    
    segment_string = things[i](segment_string)
  }

  return Array.isArray(segment_string) ? segment_string : [segment_string]
}

DAML.Parser.try_number = function(segment) {
  return (+segment === +segment) ? new DAML.Segment('Number', +segment) : segment // NaN !== NaN
}

DAML.Parser.try_string = function(segment) {
  if(segment[0] != '"' || segment.slice(-1) != '"')
    return segment    
  
  if(segment.indexOf(DAML.command_open) == -1)
    return new DAML.Segment('String', segment)
  
  return new DAML.Segment('Fing', segment) // Here 'Fing' is only to distinguish an *unprocessed* block from a Block segment with a pointer -- it only exists in this transitional phase.
}

DAML.Parser.try_list = function(segment) {
  if(segment[0] != '(' || segment.slice(-1) != ')')
    return segment
  
  segment = segment.slice(1,-1)
  return DAML.Parser.munge_list(segment)
}

DAML.Parser.munge_list = function(string) {
  var items = DAML.Parser.split_on_space(string)
                  .map(DAML.Parser.try_all_the_things)
                  .reduce(function(a,b) {return a.concat(b)}, [])
  
  return [new DAML.Segment('List', items)]
}

DAML.Parser.try_begin = function(segment) {
  var matches = segment.match(/^begin (.?\w+)/)
  if(!matches) return segment
  
  return [new DAML.Segment('Begin', matches[1])]
}

DAML.Parser.try_fancy = function(segment) {
  var regex = new RegExp('^[' + DAML.FancyGlyphs + ']')
    , matches = segment.match(regex) // THINK: would anything else ever start with a fancy glyph?
    
  if(!matches) return segment
  
  return [new DAML.Segment('Fancy', {glyph: segment.slice(0,1), word: segment.slice(1)})]
}

DAML.Parser.try_pipeline = function(segment) {
  if(segment[0] != DAML.command_open || segment.slice(-1) != DAML.command_closed)
    return segment    
    
  return [new DAML.Segment('Pipeline', segment)]
}

DAML.Parser.try_command = function(segment) {
  if(!/[a-z]/.test(segment[0])) // TODO: move all regexs into a single constants farm
    return segment              // THINK: what good is this regex?
  
  return DAML.Parser.munge_command(segment)
}

DAML.Parser.munge_command = function(string) {
  var P = DAML.Parser
    , command = {}
    , params = {}
    , items = P.split_on_space(string)
  
  /*
    Aliases and Commands:
    {math}  -- alias
    {math add}  -- command
    Find the first non-word:
    {math 1}  -- alias
    {math add 1}  -- alias
    {math add value 1}  -- command
    {math add value foo}  -- error
    ----> so we *always* know when an alias is involved.
  */
  
  /*
  
    Commands can only exist inside a pipeline between terminators
    -- add { and } as terminators
    -- need to balance try_command with try_pipeline... how does this work???
    -- add encapsulation to split_on
    - test!! compile!! rejoice!!
    - integrate partial products with CodeMirror interruptible parser
  */

  if(items.length == 1)      
    return new DAML.Segment('Alias', items[0])  // {math}
  
  if(items.length == 2) {
    if(/^[a-z]/.test(items[1]))   
      return new DAML.Segment('Command', {Handler: items[0], Method: items[1]})  // {math add}
    else
      return new DAML.Segment('Alias', {word: items[0], params: {'__alias__': P.try_all_the_things(items[1])[0] }})  // {add 1}
  }
  
  if(!/^[a-z]/.test(items[1])) {  // {add 1 to 3}
    command.type = 'Alias'
    items[0] = '__alias__'
  }
  else if(!/^[a-z]/.test(items[2])) {  // {add to 1}
    // collect alias 
    command.type = 'Alias'
    command.value = items.shift() // OPT: these shifts are probably slow...
  }
  else {  // {math add value 1}
    // collect H & M
    command.type = 'Command'
    command.value = { Handler: items.shift()
                    , Method: items.shift()}
  }
  
  // collect params
  while(items.length) {
    var word = items.shift()
    
    if(!/^[a-z]/.test(word)) {
      DAML.setError('Invalid parameter name: ' + word)
      return new DAML.Segment()
    }
    
    if(!items.length) {
      params[word] = null
      continue
    }
    
    var value = items.shift()
    params[word] = P.try_all_the_things(value)[0] // THINK: is taking the first one always right?
  }
  
  // command['string'] = string
  command.value.params = params
  return new DAML.Segment(command.type, command.value)
}

DAML.Parser.catch_all = function(segment) {
  // THINK: this is probably a symbolic alias -- could it be anything else?
  return DAML.Parser.munge_command(segment) 
}



// DAML.partially_apply = function(fun, arg, number) {
//   
// }

// DAML.maybe_call = function(member) {
//   return function(item) {
//     if(typeof item.member == 'function') {
//       return item.member()
//     }
//   }
// }


// -- wrap all the strings in the empty block
// -- wrap the parser output in the empty block
// in the param_execution_phase, execute body-less blocks 
// pass bodyblocks in as param values, so they're executed inside the command
//  >> subblocks are executed in the block.execute function, which is effectively {string join}

/*
  what to do now...
  - transforms on ptree:
    - eliminate block:body:0:block:body: configuration
  - compile to blocks and pipelines
*/



/*
  each Transformer takes a left-set of segments, the segment in question, and a right-set of segments. 
  it returns the new left and right set. the next segment from the right set is then considered, until no items remain.
  for now, all the fancy and terminator code is stuffed into these two functions.
  TODO: split out the fancys and terminators so they're added like types.
*/
DAML.TRANSFORMERS = {}

DAML.TRANSFORMERS.Terminator = function(L, segment, R) {
  if(segment.type != 'Terminator') return [L.concat(segment), R]
  
  // LE FANCY
  if(/^\//.test(segment.value)) {
    R.shift() // a comment just pops the next segment off
    // return [L, R]
  }
  
  // LE PIPE
  if(/^\|/.test(segment.value)) {
    var next = R[0]
      , prev = L[L.length - 1]
      
    // TODO: what if 'next' is eg a comment?
    // TODO: double pipe means something different
    // TODO: pipe at beginning / end (double pipe at end is common)
    
    if(next)
      next.top = true // TODO: put this elsewhere...
    
    if(next && prev) {
      next.names.push('__pipe__')
      next.inputs.push(prev.key)
      // next.params['__pipe__'] = new DAML.Segment('Input', prev.key)      
      // return [L, R]
    }
  }
  
  return [L, R]
}

DAML.TRANSFORMERS.ExtractParamsFromCommand = function(L, segment, R) {
  if(['Command', 'Alias'].indexOf(segment.type) == -1) 
    return [L.concat(segment), R]

  for(var key in segment.value.params) {
    if(!segment.value.params[key]) continue
    
    var type = segment.value.params[key].type
    
    if(typelist.indexOf(type) == -1) continue
    
    var new_segment = segment.value.params[key]
    
    segment.value.params[key] = new DAML.Segment('Input', new_segment.key)
    
    R.unshift(new_segment, segment)
    return [L, R]
  }

  return [L.concat(segment), R]
}

DAML.TRANSFORMERS.ExtractValuesFromList = function(L, segment, R) {
  if(['List'].indexOf(segment.type) == -1) 
    return [L.concat(segment), R]

  // you can't have a command in a list (you can have a pipeline, but that's different)
  // therefore we can break these two extractors apart

  var list = segment.type == 'List' ? segment.value : segment.value.params
  
  for(var key in segment.params) {
    if(!segment.params[key]) continue
    
    var type = segment.params[key].type
    
    if(typelist.indexOf(type) == -1) continue
    
    var new_segment = segment.params[key]
    
    segment.params[key] = new DAML.Segment('Input', new_segment.key)
    
    R.unshift(new_segment, segment)
    return [L, R]
  }

  return [L.concat(segment), R]
}

DAML.TRANSFORMERS.Fancy = function(L, segment, R) {
  if(segment.type != 'Fancy') return [L.concat(segment), R]

  if(!DAML.FANCIES[segment.value.glyph]) {
    // TODO: ERROR
    return [L, R]
  }

  var new_segments = DAML.FANCIES[segment.value.glyph].eat(segment)
  
  return [L.concat(new_segments), R]
}

DAML.TRANSFORMERS.List = function(L, segment, R) {
  if(segment.type != 'List') return [L.concat(segment), R]
  var typelist = ['List', 'Block', 'Pipeline', 'Fing']

  // TODO: refactor this with ExtractParams and Terminator and whatnot
  
  // If there's a list in the list, pull it out
  for(var i=0, l=segment.value.length; i < l; i++) {
    var new_segment = segment.value[i]

    if(typelist.indexOf(new_segment.type) == -1) continue
    
    segment.value[i] = new DAML.Segment('Input', new_segment.key)
    
    R.unshift(new_segment, segment)
    return [L, R]
  }

  return [L.concat(segment), R]
}

DAML.TRANSFORMERS.Fing = function(L, segment, R) {
  if(segment.type != 'Fing') return [L.concat(segment), R]

  var ablocks = DAML.string_to_ABlocks(segment.value.slice(1,-1))
    , block_ref = new DAML.Segment('Block', ablocks[0]['id'])

  block_ref.blocks = ablocks // NOTE: we suck these back out later

  return [L.concat(block_ref), R]
}

DAML.TRANSFORMERS.Pipeline = function(L, segment, R) {
  if(segment.type != 'Pipeline') return [L.concat(segment), R]

  var segments = DAML.Parser.get_fully_processed_segments_from_a_string_oh_goodness(segment.value)
    , last_segment = segments[segments.length - 1]

  R.unshift.apply(R, segments)
  
  return [L, R]
}

DAML.TRANSFORMERS.Rekey = function(L, segment, R) {
  var old_key = segment.key
    , new_key = L.length
    
  // TODO: holymuckymuck, is this ever ugly and slow. clean me!
  for(var i=0, l=R.length; i < l; i++) {
    var future_segment = R[i]
    
    if(future_segment.inputs) {
      var index = future_segment.inputs.indexOf(old_key)
      if(index)
        future_segment.inputs[index] = new_key
    }
  }
  //   if(future_segment.type == 'List') {
  //     for(var key in future_segment.value) {
  //       if( future_segment.value[key].type == "Input"
  //       &&  future_segment.value[key].value == old_key ) {
  //         future_segment.value[key].value = new_key
  //       }
  //     }
  //   }
  //   
  //   if(future_segment.type == 'Command') {
  //     if(!future_segment.params)
  //       continue
  //     for(var key in future_segment.params) {
  //       if( future_segment.params[key].type == "Input"
  //       &&  future_segment.params[key].value == old_key ) {
  //         future_segment.params[key].value = new_key
  //       }
  //     }
  //   }
  // }

  segment.key = new_key
  return [L.concat(segment), R]
}





/*
  Parser:
  - split_string
  - split_block [head | body]
  - pipeline_string_to_segments
  
  Compiler:
  - rewrite_aliases
  - rewrite_fancy
  - // combine_primitives
  - rewrite_connectors
  - remove_pipes      
  ----> except all these are inside Block and Pipeline...

*/



// DAML.Compiler.compile_segment = function(maybePtree, space, parent) {
//   // try lots of things
//   // TODO: map over things...
// 
//   if(maybePtree.block)
//     return DAML.Compiler.make_block(maybePtree, space, parent)
//   
//   if(typeof maybePtree == 'string')
//     return maybePtree
// 
//   if(maybePtree.Number)
//     return maybePtree.Number
//   
//   if(maybePtree.String)
//     return maybePtree.String
//   
//   if(maybePtree.Fancy)
//     return DAML.Compiler.compile_fancy(maybePtree.Fancy)
//   
//   if(maybePtree.List)
//     return maybePtree.List.map(function(item) {return DAML.Compiler.compile_segment(item, space, parent)})
// 
//   // THINK: these can only appear in a pipeline, not in a list or raw param...
//   if(maybePtree.Alias)
//     return DAML.Compiler.compile_alias(maybePtree)
//   
//   if(maybePtree.Handler)
//     return DAML.Compiler.compile_command(maybePtree, space, parent)
//   
//   DAML.setError("I don't know what that is")
//   
//   return ''
// }


// DAML.Compiler.compile_fancy = function(ptree) {
//   return 1234123
// }
// 
// DAML.Compiler.compile_pipeline = function(pipeline, block) {
//   return new DAML.Pipeline(pipeline, block)
// }
// 
// DAML.Compiler.compile_alias = function(ptree, space) {
//   var truename = DAML.aliases[ptree.Alias]
//   if(!truename) {
//     DAML.setError('That alias does not match any known identity')
//     return new DAML.Segment()
//   }
//   
//   // OPT: don't duplicate parsing work
//   // THINK: this skips all the nice ptree transforms and whatnot
//   var newstring = ptree.string.replace(ptree.Alias, truename)
//   return DAML.Compiler.compile_command(DAML.Parser.munge_command(newstring), space)
// }
// 
// DAML.Compiler.compile_command = function(ptree, space) {
//   if(!ptree.Handler || !ptree.Method) {
//     DAML.setError('Invalid handler or method')
//     return new DAML.Segment()
//   }
//   
//   // TODO: use the space's dialect instead of DAML.models
//   var handler = DAML.models[ptree.Handler];
//    
//   if(!handler) {
//     DAML.setError('Invalid handler')
//     return new DAML.Segment()
//   }
//   
//   var method = handler.methods[ptree.Method];
//    
//   if(!method) {
//     DAML.setError('Invalid method')
//     return new DAML.Segment()
//   }
//   
//   var fun = method.fun;
//   if(typeof fun != 'function') 
//     return DAML.onerror(daml, 'Illegal fun');
//   
//   // munge params
//   var stack = []
//     , method_params = method.params || []
//     , ptree_params = ptree.Params || []
//     , ins = {}
//     , outs = []
//     , params = []
//     , this_command = { fun: method.fun
//                      , handler: handler // bleech
//                      , method: method   // yorg
//                      , params: params
//                      , ins: ins
//                      , outs: outs}
//   
//   for(var i=0, l=method_params.length; i < l; i++) {
//     params.push(null)
//   }
//   
//   for(var key in ptree_params) {
//     var segment = ptree_params[key]
//     
//     if((test = DAML.Compiler.try_unwrap_primitive(segment)) !== false) {
//       DAML.Compiler.set_param(this_command, key, test)
//       continue
//     }
//     
//     if(test = DAML.Compiler.try_unroll_list(segment))
//       stack = stack.concat(test)
//     
//     if(test = DAML.Compiler.try_make_block(segment, this.space, this.block))
//       stack.push(test)
//     
//     if(test = DAML.Compiler.try_fix_alias(segment))
//       stack = stack.concat(test)
// 
//     if(test = DAML.Compiler.try_make_command(segment))
//       stack = stack.concat(test)
// 
//     // ugh derp derp
//     if(segment.Fancy)
//       stack.push({ fun: null
//                  , params: {}
//                  , ins: {}
//                  , outs: []})
// 
//     var rndval = Math.random() + ""
//     stack[stack.length-1].outs.push(rndval)
//     DAML.Compiler.connect_param(this_command, key, rndval)
//   }
//   
//   stack.push(this_command)
//   
//   return stack
// }



DAML.ABlock = function(head, body) {
  // soooooo... this assumes head is a bunch of segments OR body is a bunch of strings or ABlocks. right. gotcha.

  if(head) {
    // ensure it's an array of Segments, I suppose...
    this.head = head
  }
  
  if(body) {
    // TODO: filter out extracted blocks
    
    // ensure it's an array of strings and ABlocks, then take the string or block's id
    if(body.some && !body.some(function(item) {return (typeof item != 'string') && !item.id}).length) {
      this.body = body.filter(function(item) { return !item.adjunct })
                      .map(function(item) { return (typeof item == 'string') ? item : {'block': item.id} })
       // THINK: this 'block' bit is a bod block ref. should we use segments here instead?
    }
  }
  
  if(!this.head && !this.body) // THINK: when does this happen? what should we return?
    this.body = [] 
  
  var json = JSON.stringify(this)
    , hash = murmurhash(json)
    
  // THINK: take this out and put it elsewhere? or... how is block access limited? or... huh.
  if(!DAML.ABLOCKS[hash])
    DAML.ABLOCKS[hash] = this
  
  this.id = hash
}

/*
  head is an array of Segment objects, which look like {
    type: ""
    value: ...
    params: {}
    ins: {}
    outs: []
  }
  required:
  type is Number, String, List, Command, Alias, Block 
    --> during processing, various transformer types are available (currently Terminator and Fancy)
  value is {Handler: "", Method: ""} for Command, raw value otherwise
  optional:
  params is an 1D key/value for Command or Alias with "!" as implicit key and NULL for referenced values
  ins' keys are param keys, values are previous outs
  outs are labels for partial products
  
  Block is a block reference -- typically hash id
  Transformers are processed prior to ABlockiness (currently terminators and fancy)
  Aliases are converted to Commands prior to PBlockiness (and Command values are then enhanced with method pointer)
*/

DAML.segment_counter = 1

DAML.Segment = function(type, value, inputs) {
  this.key = DAML.segment_counter++ // NOTE: key is changed later in the pipeline process 
  this.type = type || 'String'
  this.value = value || ""
  if(inputs)
    this.inputs = inputs
    
  /*
    Segments also have
    params -- commands have these (it's a hash of segments)
    paramlist -- params post-dialecticalization
    method -- post-d, for Command segments
    
    Segment types: 
      paramable: String, Number, Block, Input, Null (for alias dangling params) 
      paramfree: List, Command, Alias
      temporary: Fing, Begin, Fancy, Pipeline
      
    ABlock segments (and beyond) have their keys changed to pipeline position and Input segments remapped
  */
}

DAML.Segment.prototype.unwrap = function() {
  return this.value
}



// a block is treated like a string for purposes of type coersion / inference. blocks are executed when A) explicitly run B) used as a template (explicitly run inside a command) C) inside {string join}, which is used by blocks to run internal blocks and pipelines

// a block contains either an array of text and blocks or a single pipeline [this is not quite perfect]

// DAML.PBlock = function(ABlock, space, parent) { // output var name?
//   // default to top-level space
//   if(!space)
//     space = DAML.SPACES.top
//   
//   // var pipe, block, blocks = DAML.split_string(string)
//   
//   this.space = space
//   this.varset = {}
//   if(parent)
//     this.parent = parent
//   
//   // make a pipeline out of head
//   if(ABlock.head) {
//     this.head = DAML.Compiler.compile_pipeline(ABlock.head, this)
//   }
//   
//   // what's in the body?
//   if(ABlock.body) {
//     var self = this
//     this.body = ABlock.body.map(function(item) {return DAML.ABlock_to_PBlock(item, space, self)})
//   }
// }
// 
// DAML.PBlock.prototype.execute = function(varset) {
//   if(this.head && !this.body) 
//     return this.head.execute(varset)
//   
//   var body = []
//   
//   for(var i=0, l=this.body.length; i < l; i++) {
//     var item = this.body[i]
//     
//     if(typeof item == 'string') {
//       body.push(item)
//       continue
//     }
//     
//     body.push(item.execute(varset))
//   }
//   
//   // THIS IS NOT RIGHT
// 
//   if(!this.head)
//     return body
//   
//   return this.head.execute(varset)
// }
// 
// DAML.PBlock.prototype.toString = function() {
//   return this.string;
// },
// 
// DAML.PBlock.prototype.toJSON = function() {
//   return this.string; // ??? maybe this.blocks instead?
// },
// 
// 
// 
// 
// // A Pipeline is a stack of segments and some metadata
// DAML.Pipeline = function(head, block) {
// //  var dialect = block.space.dialect
// //    , chunks = DAML.split_pipeline(string)
// //    , commands = []
// //    
// //  chunks = DAML.rewrite_aliases(chunks)
// //  chunks = DAML.rewrite_fancy(chunks) // variables and such
// //  chunks = DAML.combine_primitives(chunks, dialect) // like {(1 2) | math add} -> {math add value (1 2)}
// //  chunks = DAML.rewrite_connectors(chunks, dialect) // frame all connectors as pipes and labels
// //  chunks = DAML.remove_pipes(chunks, dialect) // convert pipes and labels to proper command stack (fun, params, name)
//   
//   // for(var i=0, l=chunks.length; i < l; i++) {
//   //   var chunk = chunks[i]
//   //     , command = {fun: chunk.fun, params: chunk.params, }
//   //   
//   //   commands.push(command)
//   // }
//   // do {
//   //   // check each item until we find a terminator
//   //   for(var index=0, l=ptree.length; index < l; index++) {
//   //     if(ptree[index].Terminator) 
//   //       break
//   //   }
//   //   if(index == l) 
//   //     break
//   //   
//   //   // hard coded pipe transformation
//   //   // TODO: move this
//   //   if(ptree[index].Terminator != '|')
//   //     break
//   //   
//   //   var before = ptree[index-1]
//   //     , after = ptree[index+1]
//   //   
//   //   before.out = index
//   //   after.in = index
//   //   
//   //   ptree.splice(index, 1);
//   //   
//   //   // ptree = DAML.Parser.transform_terminator(terminator, previous, next)
//   // } while(1)
//   // 
//   // var items = ptree.map(function(segment) {
//   //   return DAML.Compiler.compile_segment(segment, block.space, block)
//   // })
//   // 
//   // this.items = items
//   
// 
//   this.block = block
//   this.space = block.space
//   this.string = block.string
//   this.varset = {block: block.varset, space: block.space.varset}
//   
//   // ptree = DAML.Parser.transform_terminators(ptree)
//   // FIXME: crickey -- this wacks the original ptree also. VERY BAD!
//     
//   /*
//     This loop transforms the pipeline ptree array into a proper pipeline object.
//     - unwrap primitives
//     - unroll loops [creates new items]
//     - compile blocks
//     - compile commands
//     - convert aliases, and then compile them too
//     - pipe terminator changes previous and next items in the pipeline
//     
//     each stack item has
//     fun | params | in | out
//     if there's no fun then params go to out
//     
//     this works, but is quite messy. we need to refactor this loop.
//   */
//   
//   var stack = []
//     , inmods = []
//     
//   for(var i=0, l=head.length; i < l; i++) {
//     var test = false
//       , segment = head[i]
//     
//     if((test = DAML.Compiler.try_unwrap_primitive(segment)) !== false) {
//       stack.push({params: test})
//       continue
//     }
//     
//     if(test = DAML.Compiler.try_unroll_list(segment)) {
//       stack = stack.concat(test)
//       continue
//     }
//     
//     if(test = DAML.Compiler.try_make_block(segment, this.space, this.block)) {
//       stack.push(test)
//       continue
//     }
//     
//     if(test = DAML.Compiler.try_fix_alias(segment)) {
//       stack = stack.concat(test)
//       continue
//     }
// 
//     if(test = DAML.Compiler.try_make_command(segment)) {
//       stack = stack.concat(test)
//       continue
//     }
//     
//     if(segment.Terminator) {
//       // TODO: this is the pipe-specific code
//       var index = stack.length - 1
//         , previous = stack[index]
//       
//       if(!previous) continue
//       previous.outs.push(index)
//       inmods.push({ index: index+1   // herp
//                   , value: index})   // derp
//     }
//     
//   }
//   
//   for(var i=0, l=inmods.length; i < l; i++) {
//     var mod = inmods[i]
//     DAML.Compiler.connect_next_param(stack[mod.index], mod.value)
//   }
//   
//   this.stack = stack
// }
// 
// DAML.Pipeline.prototype.execute = function(varset, when_done) {
//   _.extend(this.varset, varset) // blech
//   new DAML.Process(this, when_done, this.varset).execute()
// }
// 
// 
// DAML.Compiler.connect_next_param = function(stack_item, value) {
//   // first NULL
//   var index = stack_item.params.indexOf(null)
//   if(index == -1)
//     return stack_item
// 
//   // get params from method
//   var params = stack_item.method.params || []
//   return DAML.Compiler.connect_param(stack_item, params[index].key, value)
// }
// 
// DAML.Compiler.connect_param = function(stack_item, key, value) {
//   // get params from method
//   var params = stack_item.method.params || []
//   
//   for(var i=0, l=params.length; i < l; i++) {
//     if(params[i].key == key) {
//       stack_item.ins[i] = value
//       return stack_item
//     }
//   }
//   
//   DAML.setError('Unknown param: ' . key)
//   return stack_item
// }
// 
// DAML.Compiler.set_param = function(stack_item, key, value) {
//   // get params from method
//   var params = stack_item.method.params || []
//   
//   for(var i=0, l=params.length; i < l; i++) {
//     if(params[i].key == key) {
//       stack_item.params[i] = value
//       return stack_item
//     }
//   }
//   
//   DAML.setError('Unknown param: ' . key)
//   return stack_item
// }
// 
// DAML.Compiler.try_unwrap_primitive = function(segment) {
//   if(segment.Number)
//     return segment.Number
// 
//   if(segment.String)
//     return segment.String
//   
//   return false
// }
// 
// DAML.Compiler.try_make_block = function(segment, space, parent) {
//   if(segment.block) {
//     var block = DAML.ABlock_to_PBlock(segment, space, parent)
//     return { fun: null
//            , ins: {}
//            , outs: []
//            , params: [block]}
//   }
// 
//   return false
// }
// 
// DAML.Compiler.try_fix_alias = function(segment) {
//   if(segment.Alias)
//     return DAML.Compiler.compile_alias(segment)
//     
//   return false
// }
// 
// DAML.Compiler.try_make_command = function(segment) {
//   if(segment.Handler)
//     return DAML.Compiler.compile_command(segment)
//     
//   return false
// }
// 
// DAML.Compiler.try_unroll_list = function(segment) {
//   if(segment.List)
//     return DAML.Compiler.unroll_list(segment)
//     
//   return false
// }
// 
// DAML.Compiler.unroll_list = function(list) {
//   var items = list.List
//     , stack = []
//     , values = []
//     , this_command = { fun: null
//                      , params: values
//                      , ins: {}
//                      , outs: []}
//     
//   for(var index=0, l=items.length; index < l; index++) {
//     var segment = items[index]
// 
// // THIS IS SUPER STUPID
// 
//     // here's what we need to do. 
//     // ---> if it's a simple value, keep it in the list
//     // ---> if it's complex, shift it onto the beginning of the stack and put in a reference
//     // aaaaaand that's all.
// 
// 
//     if((test = DAML.Compiler.try_unwrap_primitive(segment)) !== null) {
//       values.push(test)
//       continue
//     } else {
//       values.push(null)
//     }
// 
//     if(test = DAML.Compiler.try_unroll_list(segment))
//       stack.unshift.apply(stack, test)
// 
//     if(test = DAML.Compiler.try_make_block(segment, this.space, this.block))
//       stack.unshift(test)
// 
//     if(test = DAML.Compiler.try_fix_alias(segment))
//       stack.unshift.apply(stack, test)
// 
//     if(test = DAML.Compiler.try_make_command(segment))
//       stack.unshift.apply(stack, test)
// 
//     var rndval = Math.random() + ""
//     stack[stack.length-1].outs.push(rndval)
//     this_command.ins[index] = rndval
//   }
// 
//   stack.push(this_command)
//   return stack
// }
// 
// 
// DAML.Process = function(pipeline, when_done, varset) {
//   this.pcounter = 0
//   this.pipeline = pipeline
//   this.when_done = when_done
//   this.size = pipeline.stack ? pipeline.stack.length : 0
// 
//   this.varset = varset || {} // override-able for debugging
//   this.varset.pipe = {}
// 
// }
// 
// // DAML.Process = function() {}
// //   this.last_value = null
// //   this.pcounter = 0
// //   this.size = block.stack.length
// //   this.block = block
// //   this.when_done = when_done
// //   
// //   // before, amidst, after? maybe we don't need those...
// // }
// 
// DAML.Process.prototype.next = function(cb) {
//   var self = this
// 
//   if(this.pcounter > this.size) return false  // TODO: self-destruct, somehow? this pipeline is D-U-N.
//   
//   if(this.pcounter == this.size) {
//     if(typeof this.when_done == 'function')
//       this.when_done(this.last_value) 
//       
//     this.pcounter++
//     // this can't return anything interesting, right? i mean, our callstack is shot. there's nothing to return to.
//     return false
//   }
//   
//   var funitem = this.pipeline.stack[this.pcounter]
//   this.pcounter++
//   
//   // ... param fiddling
//   var params = funitem.params
//   for(var i=0, l=params.length; i < l; i++) {
//     if(typeof params[i] == 'function') params[i] = params[i](self)
//     // or something to that effect...
//     // __?: param[1] = function() {return self.last_value}
//     // these functions are only for type system dealings with static values and grabbing out past values.
//     // and it turns out we need all the values for this stack recorded, because if we have a command with a lot of params that are functions (e.g. vars or blocks) we'll need to reference each of those lines
//     
//   }
//   
//   // async case
//   // if(funitem.flags.async) { 
//   //   var new_cb = function(val) {
//   //     self.last_value = val 
//   //     cb(val)
//   //   }
//   //   params.push(new_cb)
//   //   // return funitem.fun.apply(funitem.model, params)
//   // }
//   
//   // either way
//   // this last_value assignment is overridden in new_cb by async
//   if(!funitem.fun)
//     return params
//   
//   self.last_value = funitem.fun.apply(funitem.model, params)
//   
//   return true
//   
//   // return !!funitem.flags.async
// }
// 
// DAML.Process.prototype.bound_next = function() {
//   return this.next.bind(this)
// } 
// 
// DAML.Process.prototype.reset = function() {
//   // THINK: this is probably a bad idea, but it makes debugging easier... can we reuse stacks?
//   this.last_value = null
//   this.pcounter = 0
// } 
// 
// DAML.Process.prototype.execute = function() {
//   var self = this
//   var my_cb = function() {self.run()}
//   while(this.pcounter <= this.size) {
//     this.next(my_cb)
//   }
//   return this.last_value
// } 


DAML.blockhead_to_pipeline = function(blockhead, dialect) {
  var pipeline = JSON.parse(JSON.stringify(blockhead)) // clone it
  
  pipeline = DAML.mungeLR(pipeline, dialect.convert_aliases.bind(dialect))
  pipeline = DAML.mungeLR(pipeline, dialect.connect_commands.bind(dialect)) // THINK: this could probably be a map, since it's 1-1
  
  return pipeline
}




DAML.Dialect = function(models, aliases, parent) {
  this.models = models
  this.aliases = aliases
  this.parent = parent
}

DAML.Dialect.prototype.get_handler = function(handler) {
  if(  handler 
    && this.models
    && this.models[handler]
    && this.models[handler]
  ) {
    return this.models[handler]
  }

  return false
}

DAML.Dialect.prototype.get_method = function(handler, method) {
  if(  handler 
    && method
    && this.models
    && this.models[handler]
    && this.models[handler].methods
    && this.models[handler].methods[method]
  ) {
    return this.models[handler].methods[method]
  }

  return false
}

DAML.Dialect.prototype.convert_aliases = function(L, segment, R) {
  if(segment.type != 'Alias') return [L.concat(segment), R]
    
  var dialect = this
    , replacements = dialect.aliases[segment.value]
  
  if(!replacements) {
    // THINK: warning?
    return [L, R]
  }
  
  replacements = JSON.parse(JSON.stringify(replacements)) // clone it
  
  var last_replacement = replacements[replacements.length - 1]
  
  if(!last_replacement)
    return [L, R]
  
  // merge alias with last replacement segment by combining params, ins, and outs
  // TODO: refactor this bit
  
  /*
  
    Generally: 
    - never override aliased params
    - an alias may have a 'dangling param', which has no fixed value. it takes the first value in this order
      - the value immediately after the alias, e.g. {add 777}
      - the pipe value, e.g. {777 | add}
    - note that a dangling param will never be set by directly specifying the param value, e.g. {add value 777} does nothing
  
    CASES:
    
    {add}                        --> do nothing
    {add to 3}                   --> rep.to = seg.to
    {add value 3}                --> do nothing
    {add 3}                      --> rep.value = seg.__alias__
    {add 3 to 5}                 --> rep.value = seg.__alias__, rep.to = seg.to
    {add 3 value 5}              --> rep.value = seg.__alias__
    {add value 5 to 3}           --> rep.to = seg.to
    
    {2 | add}                    --> rep.value = seg.__pipe__
    {2 | add 3}                  --> rep.value = seg.__alias__, rep.to = seg.__pipe__
    {2 | add 3 to 5}             --> rep.value = seg.__alias__, rep.to = seg.to
    {2 | add 3 value 5}          --> rep.value = seg.__alias__
    {2 | add value 5 to 3}       --> rep.value = seg.__pipe__, rep.to = seg.to
    
  */
  
  if(segment.params) {
    last_replacement.params = last_replacement.params || {}
    
    for(var key in segment.params) {
      if(key == '__pipe__') {
        last_replacement.params[key] = segment.params[key] // always add the __pipe__
      }
      if(key == '__alias__') {
        // find last_replacement's dangling param
        for(var other_key in last_replacement.params) {
          if(last_replacement.params[other_key].type == 'Null') {
            last_replacement.params[other_key] = segment.params[key]
            break
          }
        }
      }
      else if(!last_replacement.params[key]) { // unoccupied param
        last_replacement.params[key] = segment.params[key]
      }
    }      
  }
  
  // if(segment.ins) {
  //   last_replacement.ins = last_replacement.ins || {}
  //   
  //   for(var key in segment.ins) {
  //     last_replacement.ins[key] = segment.ins[key]
  //   }
  // }
  
  // last_replacement.outs = last_replacement.outs ? last_replacement.outs.concat(segment.outs || []) : segment.outs
  // last_replacement.outs = segment.outs // THINK: this is probably always right...
  
  return [L.concat(replacements), R]
}

DAML.Dialect.prototype.connect_commands = function(L, segment, R) {
  if(segment.type != 'Command') return [L.concat(segment), R]
  
  segment.handler = this.get_handler(segment.value.Handler)
  segment.method = this.get_method(segment.value.Handler, segment.value.Method)
  
  if(!segment.method) {
    // THINK: error?
    return [L, R] // THINK: maybe {} or {noop: true} or something, so that false flows through instead of previous value
  }
  
  var piped = false
    , param_value
    , key, name_index
    , params = {}
  
  segment.paramlist = []
  
  for(var index in segment.method.params) {
    key = segment.method.params[index].key
    param_value = false
    
    // THINK: how do we allow storage / performance optimizations in the segment structure -- like, how do we fill in the params ahead of time? 
    
    name_index = names.indexOf(key)
    if(name_index != -1) {
      param_value = segment.inputs[name_index]
    }
    else if(!piped) {
      name_index = names.indexOf('__pipe__')
      if(name_index != -1) {
        param_value = segment.inputs[name_index]
        piped = true
      }
    }
    
    // if(params[key]) {
    //   param_value = params[key]
    // }
    // else if(!piped && params['__pipe__']) {
    //   param_value = params['__pipe__']
    //   piped = true
    // }
    
    if(param_value === false) { 
      // param_value = new DAML.Segment('Null')
      param_value = false // oh boy...
    }
    
    segment.paramlist.push(param_value)
  }

  return [L.concat(segment), R]
}

DAML.DIALECTS.top = new DAML.Dialect(DAML.models, DAML.aliases)

/*

  We could consider having a NULL global value. nothing would return it. undefined variables are NULL. a param set to NULL like {math add value (1 2 3) to NULL} will drop the param (so that would return 6). as opposed to {math add value (1 2 3) to FALSE} which would return (1 2 3) or {math add value (1 2 3) to TRUE} which would return (2 3 4)

  yuck type conversions yuck yuck. 
  maybe just NULL and not TRUE/FALSE? what's the use case for those again?
*/

DAML.Space = function(dialect, parent) {
  this.dialect = dialect
  
  if(parent)
    this.parent = parent
}

DAML.Space.prototype.deliver = function(message) {
  // do something smart
}

// TODO: move this all into a Process, instead of doing it here.
// THINK: there's no protection in here again executing multiple processes concurrently in the same space -- which is bad. find a way to bake that in. [except for those cases of desired in-pipeline parallelism, of course]
DAML.Space.prototype.execute = function(ablock, callback) {
  // var pblock = DAML.ABlock_to_PBlock(ablock, this)
  
  if(!callback) {
    callback = function(result) {
      // THINK: what should we do here?
      console.log(result)
    }
  }
  
  if(Array.isArray(ablock))
    ablock = ablock[0]
  
  if(ablock.head) {
    this.execute_head(ablock.head, callback)
  }
  else {
    this.execute_body(JSON.parse(JSON.stringify(ablock.body)), '', callback, this)
  }
}

DAML.Space.prototype.execute_head = function(head, callback) {
  var pipeline = DAML.blockhead_to_pipeline(head, this.dialect)
    , varset = {}
    , value = null
    
  
  // TODO: async
  for(var i=0, l=pipeline.length; i < l; i++) {
    var segment = pipeline[i]
      , params = segment.paramlist || []

    for(var ii=0, ll=params.length; ii < ll; ii++) {
      if(params[ii] && params[ii].type == 'Input') { // TODO: change 'ins' to just Input segments (!!!)
        params[ii] = varset[params[ii].value] // TODO: or null
      }
    }
    
    if(segment.method) {
      /* 
        
        HEY! LOOK OVER HERE!
        -- fix fancy segments before you get here! (in try_fancy)
        - use the type system to unwrap params!
        - rejoice!
      
      */
      
      // OPT: yeah yeah
      var method_params = segment.method.params
        , errors = []
        , typefun
      
      for(var iii=0, lll=params.length; iii < lll; iii++) {
        if(method_params[iii] && !method_params[iii].type && DAML.TYPES[method_params[iii].type])
          typefun = DAML.TYPES[method_params[iii].type]
        else
          typefun = DAML.TYPES.anything
        
        var param = params[iii]
          , pval  = param.unwrap()
        
        if(param && param.type) { // proper segment
          params[iii] = typefun(pval)
        }
        else if(method_params[iii].fallback) {
          params[iii] = typefun(method_params[iii].fallback)
        }
        else if(method_params[iii].required) {
          errors.push('Missing required parameter: ' + method_params[iii].key)
          params[iii] = typefun(undefined)
        }
        else {
          params[iii] = typefun(undefined)
        }
        // TODO: params[iii] = undefined, if param.undefined is set....
      }
      
      if(!errors.length) {
        value = segment.method.fun.apply(segment.handler, params)
      } else {
        // TODO: ERRORS
        value = null
      }
      
    } 
    else {
      // TODO: refactor this
      if(segment.value) {
        value = segment.value // THINK: what should we really do here? primitive.unwrap? unbox? 
      }
      else if(segment.params) {
        value = segment.params // THINK: what is this for? what's going on?
      }
      else {
        value = null
      }
    }
    
    varset[segment.key] = value
    
    // outs
    // for(var iiii=0, llll=outs.length; iiii < llll; iiii++) {
    //   varset[outs[iiii]] = value
    // }
  }
  
  callback(value)
}

DAML.Space.prototype.execute_body = function(body, output, callback) {
  var item = body.shift() // OPT: shift is slow
    , new_cb = false
    , space = this
    
  if(typeof item == 'string') {
    if(!body.length)
      callback(output + item)
    else
      space.execute_body(body, output + item, callback)
    return
  }
    
  if(!body.length) {
    new_cb = function(result) {
      callback(output + result)
    }
  } 
  else {
    new_cb = function(result) {
      space.execute_body(body, output + result, callback)
    }
  }
  
  // TODO: refactor this
  var ablock = DAML.ABLOCKS[item.block]
  if(!ablock) {
    // TODO: throw ERROR
    new_cb('')
  }
  
  if(ablock.head) {
    this.execute_head(ablock.head, new_cb)
  }
  else {
    this.execute_body(JSON.parse(JSON.stringify(ablock.body)), '', new_cb, this)
  }  
  
  // if(item.block) {
  //   
  //   body = item.body.concat(body)
  //   space.execute_body(body, output + result, new_cb)
  // } 
  // else {
  //   space.execute_head(item.head, new_cb)
  // }
}


DAML.SPACES.top = new DAML.Space(DAML.DIALECTS.top)




//////// MORE HELPERS //////////


DAML.Parser.split_on = function(string, regex, label) {
  if(typeof string != 'string') 
    return string
  
  if(!(regex instanceof RegExp))
    regex = RegExp('[' + DAML.ETC.regex_escape(regex) + ']')
  
  var output = []
    , inside = []
    , special = /["{()}]/
    , match_break = 0
    , char_matches = false
    , we_are_matching = false
    
  for(var index=0, l=string.length; index < l; index++) {
    
    /*
      we need to not match when
      - inside quotes
      - unmatched parens
      - unmatched braces
    */
    
    var this_char = string[index]
      , am_inside = inside.length
    
    if(this_char == '"' && inside.length == 1 && inside[0] == '"')
      inside = []
    
    if(this_char == '"' && !am_inside)
      inside = ['"']
    
    if(this_char == '{') 
      inside.push('{')
    
    if(this_char == '(')
      inside.push('(')
    
    if(this_char == '}' || this_char == ')')
      inside.pop() // NOTE: this means unpaired braces or parens in quotes are explicitly not allowed... 
    
    char_matches = regex.test(this_char)
    
    // if(!!am_inside == !!inside.length) // not transitioning
    //   continue
    //   output.push(string.slice(match_break, index + 1))
    //   match_break = index + 1
    // }
    // 
    // if(!am_inside && inside.length) {
    //   output.push(string.slice(match_break, index))
    //   match_break = index
    // }
    // 
    // if(special.test(this_char))
    //   continue
    // 

    if(am_inside && inside.length)
      continue
    
    if(we_are_matching === char_matches) 
      continue

    if(we_are_matching) { // stop matching
      if(label)
        output.push(new DAML.Segment(label, string.slice(match_break, index)))
      
      match_break = index
      we_are_matching = false
    }
    
    else { // start matching
      if(index)
        output.push(string.slice(match_break, index))

      match_break = index
      we_are_matching = true      
    }
  }
  
  if(match_break < index)
    output.push(string.slice(match_break, index))
  
  return output
}

DAML.Parser.split_on_terminators = function(string) {
  return DAML.Parser.split_on(string, DAML.Tglyphs, 'Terminator')
}

DAML.Parser.split_on_space = function(string) {
  return DAML.Parser.split_on(string, /[\s\u00a0]/)
}

// give each item its time in the sun. also, allow other items to be added, removed, reordered or generally mangled
DAML.mungeLR = function(items, fun) {
  var L = []
    , R = items
    , item = {}
    , result = []
  
  if(!items.length) return items
  
  do {
    item = R.shift() // OPT: shift is slow
    result = fun(L, item, R)
    L = result[0]
    R = result[1]
  } while(R.length)
  
  return L
}



/////// SOME HELPER METHODS PUUKE ///////////

DAML.ETC.isNumeric = function(value) {
  return (typeof(value) === 'number' || typeof(value) === 'string') && value !== '' && !isNaN(value)
}

DAML.ETC.toNumeric = function(value) {
  if(value === '0') return 0
  if(typeof value == 'number') return value
  if(typeof value == 'string') return +value ? +value : 0
  return 0
}

DAML.ETC.regex_escape = function(str) {
  var specials = /[.*+?|()\[\]{}\\$^]/g // .*+?|()[]{}\$^
  return str.replace(specials, "\\$&")
}

DAML.ETC.flag_checker_regex = /\/(g|i|gi|m|gm|im|gim)?$/

DAML.ETC.string_to_regex = function(string, global) {
  if(string[0] !== '/' || !DAML.ETC.flag_checker_regex.test(string)) {
    return RegExp(DAML.ETC.regex_escape(string), (global ? 'g' : ''))
  }
  
  var flags = string.slice(string.lastIndexOf('/') + 1)
  string = string.slice(1, string.lastIndexOf('/'))
  
  return RegExp(string, flags)
}

DAML.ETC.is_false = function(value) {
  if(!value) return true // '', 0, false, NaN, null, undefined
  if(typeof value == 'object' && _.isEmpty(value)) return true // empty lists too
}


// via https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Function/bind
if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== "function") {
      // closest thing possible to the ECMAScript 5 internal IsCallable function
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }
 
    var aArgs = Array.prototype.slice.call(arguments, 1), 
        fToBind = this, 
        fNOP = function () {},
        fBound = function () {
          return fToBind.apply((this instanceof fNOP && oThis) ? this: oThis,
                               aArgs.concat(Array.prototype.slice.call(arguments)));
        };
 
    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
 
    return fBound;
  };
}



DAML.import_aliases({
  '>': 'variable set path',
  'grep': 'string grep on',
  
  'run': 'daml run',
  'quote': 'daml quote',
  'unquote': 'daml unquote',
  
  '*': 'list pair value',
  'merge': 'list merge',
  'each': 'list each',
  'map': 'list map',
  'sort': 'list sort',
  'ZZZgroup': 'list group',
  'prune': 'list prune daml',
  'extract': 'list extract daml',
  'count': 'list count value',
  'union': 'list union value',
  
  // '%': 'content get value',
  
  'eq': 'logic is like',
  'is': 'logic is', // for 'is in'
  'if': 'logic if value',
  'then': 'logic if value __ then',
  'else': 'logic if value __ then __ else',
  'and': 'logic and value',
  'or': 'logic or value',
  'not': 'logic not value',
  'cond': 'logic cond value',
  
  'add': 'math add value',
  'subtract': 'math subtract value', // 'minus' is sometimes better, but with constants we'll use 'add -N'
  'multiply': 'math multiply value',
  'divide': 'math divide', // careful, this one is different
  'round': 'math round',
  'mod': 'math mod by',
  'less': 'math less',
  
  'log': 'process log value',
  'tap': 'process log passthru 1 value',
})