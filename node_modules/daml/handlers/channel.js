// A channel has some inports, some outports, and can have values manually pushed on to it. they connect [spaces | gateways] to [spaces | gateways]

DAML.import_models({
  channel: {
    desc: 'Commands for channel manipulation',
    methods: {
      
      add: {
        desc: 'Add a new channel',
        params: [
          { key: 'name'
          , desc: 'The name for the channel -- currently needs to be unique systemwide'
          , type: 'string'
          , required: true
          }, // THINK: mix/match with commas first is weird, but it's all a hack to get around needing commas in the first place.
        ],
        fun: function(name) {
          DAML.CHANNELS[name] = {
            name: name
          }
          
          // THINK: how do we constrain which spaces have access to this channel??
          return name
        },
      },
      
      attach: {
        desc: 'Connect a space or gateway to the beginning or end of a channel',
        params: [
          {
            key: 'name',
            desc: 'The channel name',
            type: 'string',
            required: true
          },
          {
            key: 'side',
            desc: 'Either start or end', 
            type: 'string',
          },
          {
            key: 'gateway',
            desc: 'The gateway name',  // THINK: how do we make this work with spaces?
            // TODO: modify the type system: 
            // type: Either('start', 'end')
            // type: ListOf('number')
            // golly...
            type: 'string',
          },
        ],
        fun: function(name, side, gateway_name) {
          var channel = DAML.CHANNELS[name]
            , gateway = DAML.GATEWAYS[gateway_name]
          
          if(!channel) {
            DAML.setError('That is not a valid channel')
            return name
          }
          
          if(!gateway) {
            DAML.setError('That is not a valid gateway')
            return name
          }

          // TODO: limit side to 'start' or 'end'
          if(!channel[side])
            channel[side] = []
            
          channel[side].push(gateway) // store by reference... hmmmm.
          
          return name
        },
      },
      
      send: {
        desc: "Send a value directly onto a channel",
        params: [
          {
            key: 'name',
            desc: 'A channel name',
            type: 'string',
            required: true
          },
          {
            key: 'value',
            desc: 'A value to send',
            type: 'anything',
            required: true
          },
        ],
        fun: function(name, value) {
          var channel = DAML.CHANNELS[name]
          
          if(!channel) {
            DAML.setError('That is not a valid channel')
            return name
          }
          
          var endpoints = channel.end
          
          if(!endpoints || !endpoints.length)
            return value // no endpoint, so do nothing 
            // THINK: should we consider an option for blocking channels that wait for an endpoint to 'be ready to receive'?
            
          endpoints.forEach(function(gateway) {
            DAML.execute('gateway', 'send', [gateway.name, value]) // TODO: herpderp -- need to send a callback, have this respect space, etc etc etc
          })
          
          return value
        },
      },
      
    }
  }
})