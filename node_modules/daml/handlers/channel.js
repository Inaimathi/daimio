// A channel has some inports, some outports, and can have values manually pushed on to it. they connect gateways to gateways

DAML.import_models({
  channel: {
    desc: 'Commands for channel manipulation',
    methods: {
      
      add: {
        desc: 'Add a new channel',
        params: [
          { key: 'name'
          , desc: 'The name for the channel -- currently needs to be unique systemwide'
          , type: 'string'
          , required: true
          }, // THINK: mix/match with commas first is weird, but it's all a hack to get around needing commas in the first place.
        ],
        fun: function(name) {
          DAML.CHANNELS[name] = {
            name: name,
            startpoints: [],
            endpoints: []
          }
          
          // THINK: how do we constrain which spaces have access to this channel??
          return name
        },
      },
      
      'attach-to-start': {
        desc: 'Connect a gateway to the beginning of a channel',
        params: [
          {
            key: 'name',
            desc: 'The channel name',
            type: 'string',
            required: true
          },
          // {
          //   key: 'side',
          //   desc: 'Either start or end', 
          //   type: 'string',
          // },
          {
            key: 'gateway',
            desc: 'The gateway name',
            // TODO: modify the type system: 
            // type: Either('start', 'end')
            // type: ListOf('number')
            // type: ListOf('anything')
            // golly...
            type: 'string',
          },
        ],
        fun: function(name, gateway_name) {
          var channel = DAML.CHANNELS[name]
            , gateway = DAML.GATEWAYS[gateway_name]
          
          if(!channel) {
            DAML.setError('That is not a valid channel')
            return name
          }
          
          if(!gateway) {
            DAML.setError('That is not a valid gateway')
            return name
          }
          
          channel.startpoints.push(gateway)
          
          var cb = function(value, callback) {
            channel.endpoints.forEach(function(end_gateway) {
              end_gateway.sendMessage(value, callback)
            })
          }
          
          gateway.addListener(cb)
          
          return name
        },
      },
      
      'attach-to-end': {
        desc: 'Connect a gateway to the end of a channel',
        params: [
          {
            key: 'name',
            desc: 'The channel name',
            type: 'string',
            required: true
          },
          {
            key: 'gateway',
            desc: 'The gateway name',
            type: 'string',
          },
        ],
        fun: function(name, gateway_name) {
          var channel = DAML.CHANNELS[name]
            , gateway = DAML.GATEWAYS[gateway_name]
          
          if(!channel) {
            DAML.setError('That is not a valid channel')
            return name
          }
          
          if(!gateway) {
            DAML.setError('That is not a valid gateway')
            return name
          }
          
          channel.endpoints.push(gateway)
          
          return name
        },
      },
      
      send: {
        desc: "Send a value directly onto a channel",
        params: [
          {
            key: 'name',
            desc: 'A channel name',
            type: 'string',
            required: true
          },
          {
            key: 'value',
            desc: 'A value to send',
            type: 'anything',
            required: true
          },
        ],
        fun: function(name, value, callback) {
          var channel = DAML.CHANNELS[name]
          
          if(!channel) {
            DAML.setError('That is not a valid channel')
            return name
          }
          
          // THINK: should we consider an option for blocking channels that wait for an endpoint to 'be ready to receive'?
            
          channel.endpoints.forEach(function(end_gateway) {
            end_gateway.sendMessage(value, callback)
          })
        
          return value
        },
      },
      
    }
  }
})