// commands for fiddling with daml directly

DAML.import_models({
  daml: {
    desc: 'Commands for DAML manipulation',
    methods: {
      
      // {daml do handler : method : params {* ()} }
      // {daml sandbox allow (:verb :noun :story :dom) remove {* (:story (:add :set_noun))} do $foo}
      
      
      import: {
        desc: 'Import a set of commands into the local DAML dialect',
        params: [
          {
            key: 'block', // THINK: this should be called 'daml'... /sigh
            desc: 'A DAML string',
            type: 'block',
            required: true,
          },
          {
            key: 'into',
            desc: 'A model to import into',
            type: 'string',
            required: true,
            falsy: false,
          },
          {
            key: 'as',
            desc: "The new method's name",
            type: 'string',
            required: true,
            falsy: false,
          },
          {
            key: 'params',
            desc: 'A list of parameters',
            type: 'list',
            fallback: []
          },
        ],
        fun: function(template, into, as, params) {
          var obj={}, pobj=[], fun
          
          // TODO: throw a warning when importing a template that references non-local variables [a block wrapped in a command can only read params and locally declared vars, and can only produce a single output stream (no external (e.g. global) var writing, e.g.)] -- ie, imported commands have no runtime state side effects (though they may touch the db, eg), and aren't influenced by their environment. they neither influence nor are influenced by their environment. whereas general blocks are like plugable puzzle pieces that accept inputs from their environment and can alter it in various ways (including piping the standard output to other places, but also directly mutating environmental variables).
          
          // THINK: maybe the above applies to closed spaces, not commands. but i dunno.
          
          // TODO: allow hashes as params 
          for(var i=0, l=params.length; i < l; i++) {
            pobj.push({key: params[i], desc: "A param"})
          }
          
          funthunker = function() {
            DAML.execute('variable', 'push_context', [])
            for(var i=0, l=params.length; i < l; i++) {
              DAML.execute('variable', 'set', [params[i], arguments[i]])
            }
            var output = template.toFun()
            DAML.execute('variable', 'push_context', [])
            return output
          }

          obj[into] = {methods: {}}
          obj[into]['methods'][as] = {"params": pobj, "fun": funthunker}
          
          DAML.import_models(obj)
        },
      },
      
      alias: {
        desc: "Create a new alias.",
        params: [
          {
            key: 'string',
            desc: "A string",
            type: "string",
            required: true,
            falsy: false,
          },
          {
            key: 'as',
            desc: "The newer, shorter string",
            type: "string",
            required: true,
          },
        ],
        fun: function(string, as) {
          var obj = {}
          obj[as] = string
          DAML.import_aliases(obj)
          return ""
        },
      },
      
      quote: {
        desc: "Return a pure string, possibly containing DAML",
        params: [
          {
            key: 'value',
            desc: "A string",
            type: "string",
            required: true,
          },
        ],
        fun: function(value) {
          return value // type system handles the escaping
        },
      },
      
      unquote: {
        desc: "Convert a string into a block. This will eventually execute (it's a bit like a delayed run), so use it carefully",
        params: [
          {
            key: 'value',
            desc: "A string",
            type: "string",
            required: true,
          },
        ],
        fun: function(value) {
          // return DAML.compile(value)
        },
      },
      
      run: {
        desc: "Completely process some DAML",
        params: [
          {
            key: 'value',
            desc: "Some DAML",
            type: "string",
            required: true,
          },
        ],
        fun: function(value) {
          return DAML.run(value)
        },
      },
      
      parse: {
        desc: "Convert a DAML string's canonical ptree",
        params: [
          {
            key: 'string',
            desc: "The stage key",
            type: "string",
          },
        ],
        fun: function(string) {
          return DAML.parse(string)
        },
      },
      
    }
  }
})