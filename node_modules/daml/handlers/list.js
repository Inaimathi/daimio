// A list in DAML is an ordered sequence of items that are optionally keyed.

DAML.import_models({
  list: {
    desc: 'Commands for list manipulation',
    help: 'A list in DAML is an ordered sequence of items that are optionally keyed. Anything you can do with a classic list or hash you can do with a DAML list. It is the fundamental data structure in DAML.',
    methods: {
      
      map: {
        desc: 'Run DAML for each item, returning a list',
        params: [
          {
            key: 'data',
            desc: 'An array of data',
            type: 'list',
            required: true
          },
          {
            key: 'block',
            desc: 'The daml to run',
            type: 'block',
            required: true
          },
        ],
        fun: function(data, block, callback) {
          
          // THINK: change 'value' to 'this'!!
          // THINK: change 'this' to '_this'!! 
          // (because you can't write to it, and these *should* be immutable -- plus then they're cheaper!)
          
          
          // THINK: can we do something like {user find | __.username | map :trim}
          // or even {user find | __.username | map "trim | reverse | __.#2 | uppercase"}
          // like, pass the value in as __ and append that to the first pipe chunk?
          // but not {user find | __.username | map "{_this | trim | reverse | __.#2 | uppercase}"} ?
          // because that looks ok to me. we don't want implicit __ on entry: it mucks up params.
          
          // what about 'extract' where you need 'this' and 'parent'? 
          // or here where 'key' would be nice?
          
          // TODO: add path param! easy changes to nested values!
          // TODO: add 'this' param (and 'key'?) to each of these.
          
          /* THINK: an 'into' param, for making a new list with the same top-level keys. [nope]
             note: ruby calls this 'collect'... but in daml it doesnt matter. it's not needed. duh!
          
          __.^.* takes incoming, goes up the tree, then takes all the children -- ie collects all siblings. need real commands -- this is good sugar, but what if you only want some sibs? like sibs that aren't you?

          THINK: that above bit doesn't allow us to pop shortcuts for greater clarity. move most of the __... style filtering to commands and aliases. also, disable implicit piping to first param when __ is used explicitly, so you can use it e.g. in fancy find commands with five by_* params. no, no, disable it after ||, but let __ through.
          

          
          map examples: 
            {((1 2 3) (4 5 6)) | map "{add}"}
            {profile find | map "{keep (:name :address :phone)}"}
            {profile find ^ keep (:name :address :phone) ^_^ map ^0}

            filtering on keys (show both remove and keep):
            scala: map filterKeys (Set("1", "2") and Set("2", "3"))
            scala: map filterKeys !Set("2", "3")
            clojure: (select-keys m [:a :b])
            clojure: (filter (fn [x] (some #{(key x)} [:a :b])) m)
            python: x = { your_key: old_dict[your_key] for your_key in your_keys }
            ruby: x.slice("one", "two")
            ruby: x.except("three")
            ruby: x.reject {|k,v| k == "three"}
            ruby: x.select { |key,_| wanted_keys.include? key }
            daml: ???
            
            
            scala: 
              val mustReport = trades filter (uncoveredShort ∨ exceedsDollarMax)
              val european = { 
                val Europe = (_ : Market).exchange.country.region == Region.EU
                trades filter (_.market ∈: Europe)
              }
          */
          
          // for asyncable loops you have to plug this in to the bottom of the newly created stack formed by the template param. otherwise you'll bomb your serial asyncing. could do it only if the template is flagged 'async', but for now just have a single loop structure that takes a template, a dataset and a closure, sticks it into a block and runs it. 
          // also, this is pretty cool that you can do that.
          // also, unify the convention for dislodging async calls (into another timeline)
          // also: merge (and map/each to a lesser extent) creates a variable shadowing issue. so you can definitely shoot yourself in the foot with that. but it also provides an encapsulation var path, so you can avoid it. but it requires some thinking. i suspect this will trip a lot of people up. is there a better way that still allows the pretty syntax? maybe we can at least throw a warning so you can see where it's happening in the graph...
          
          
          // TODO: 'walk' command: pattern:bfs/dfs, apply:downward/upward, template, value ... or just add this to map? its a map walk. map walking. hmmm. someone has probably thought of this before...
          
          // TODO: 'zip' command: takes N arrays of M elements and makes a single array with M elements where the Kth item is an array of the Kth items from all of the initial arrays. e.g. ((1 2 3) (4 5 6)) -> ((1 4) (2 5) (3 6))
          
          
          var result = []
            , counter = 0
            , size = data.length

          var mapper = function() {
            if(counter == size) {
              callback(result)
            }
            else {
              // push data[counter] onto the execution context as __
              var scope = {}
              scope["-1"] = data[counter]
              
              block(function(value) {
                result[counter] = value
                counter++
                mapper()
              }, scope)
            }
          }
          
          mapper()
          
          return NaN
        },
      },
      
      each: {
        desc: 'Run DAML for each item, returning a string',
        params: [
          {
            key: 'data',
            desc: 'An array of data',
            type: 'list',
            required: true
          },
          {
            key: 'block',
            desc: 'The daml to run',
            type: 'block',
            required: true
          },
        ],
        fun: function(data, block, callback) {
          var result = ''
            , counter = 0
            , size = data.length

          var mapper = function() {
            if(counter == size) {
              callback(result)
            }
            else {
              // push data[counter] onto the execution context as __
              var scope = {}
              scope["-1"] = data[counter]
              
              block(function(value) {
                result += DAML.stringify(value)
                counter++
                mapper()
              }, scope)
            }
          }
          
          mapper()
          
          return NaN
          
          // TODO: also push the "row count" into the local context
          // THINK: (but how do we say "give me number 5 from data" when 5 is a var?) -- oh right foo.{"#{rows | mod {foo | count}}"} --- maybe we can make that easier?
          // TODO: allow key, value and count alias names to be overridden
          // TODO: only push these vars into the local context, not vars created in the daml
          // TODO: merge is just an each couple with a 'with' type statement... and map is similar too. can we use that?
          // TODO: merge should take a 'rowname' param that allows you to access the row's keys via an alias instead of pushing them into the var env.
          

          // okay, but if we're doing {@qids | each daml "{answer add id value answer @answers.{key}}"}
          // what is the key if qids is an unkeyed list? default to integers? then you *can* access by int, not just position. oy.
          
          
          // DAML.execute('variable', 'push_context')
          // 
          // for(var key in data) {
          //   DAML.execute('variable', 'set', ['key', key])
          //   DAML.execute('variable', 'set', ['value', data[key]]) // this bypasses the type system
          //   output += DAML.run(block)
          //   // output += DAML.stringify(DAML.defunctionize(daml.toFun())) // do the defunc here, otherwise stringify does a block check first. 
          //   // TODO: figure out a better way to design this...
          // }
          // 
          // DAML.execute('variable', 'pop_context')
          // 
          // return output
        },
      },
      
      merge: {
        desc: "Merge data with a template, returning a string",
        params: [
          {
            key: 'data',
            desc: 'An array of data',
            type: 'list',
            required: true
          },
          {
            key: 'block',
            desc: 'The daml to run',
            type: 'block',
            required: true
          },
        ],
        fun: function(data, block, callback) {
          var result = ''
            , counter = 0
            , size = data.length

          var mapper = function() {
            if(counter == size) {
              callback(result)
            }
            else {
              // push data[counter] onto the execution context as __
              var scope = {}
                , datum = data[counter]
              for(var key in datum) {
                scope['_' + key] = datum[key]
              }
              scope["-1"] = datum
              
              block(function(value) {
                result += DAML.stringify(value)
                counter++
                mapper()
              }, scope)
            }
          }
          
          mapper()
          
          return NaN
          
          // var output = ''
          // 
          // DAML.execute('variable', 'push_context')
          // 
          // for(var outer_key in data) {
          //   var datum = data[outer_key]
          //   if(typeof datum != 'object') continue
          // 
          //   for(var inner_key in datum) {
          //     DAML.execute('variable', 'set', [inner_key, datum[inner_key]]) // NOTE: this bypasses the type system
          //   }
          //   
          //   output += block
          //   // output += DAML.stringify(DAML.defunctionize(daml.toFun())) // see above notes on defunc
          // }
          // 
          // DAML.execute('variable', 'pop_context')
          // 
          // return output
        },
      },
      
      from_json: {
        desc: "Convert from a JSON string to a list",
        params: [
          {
            key: 'value',
            desc: 'The string to convert',
            type: 'string'
          }
        ],
        fun: function(value) {
          if(!value) return []
          // TODO: wrap this in a try/catch!
          return JSON.parse(value)
        },
      },
      
      to_json: {
        desc: "Convert a list to a JSON string",
        params: [
          {
            key: 'value',
            desc: 'The list to convert',
            type: 'anything'
          }
        ],
        fun: function(value) {
          return JSON.stringify(value)
        },
      },
      
      count: {
        desc: "Count the items in a list",
        params: [
          {
            key: 'value',
            desc: 'The list to count',
            type: 'list' // ListOrEmptyList
          }
        ],
        fun: function(value) {
          return value.length
        },
      },
      
      pair: {
        desc: "Create a new list, using the first item as its first key, the second item as that value, and so on.",
        params: [
          {
            key: 'value',
            desc: 'The list to convert',
            type: 'list'
          }
        ],
        fun: function(value) {
          var k, v, hash = {}
          
          if(value.length < 2) {            
            return DAML.setError('The value parameter must contain at least two elements')
          }

          // THINK: consider whether this could clobber variables passed in as values (do we need to deep clone?)

          while(value.length > 1) 
          {
            k = String(value.shift())
            v = value.shift()
            hash[k] = v
          }

          return hash
        },
      },
      
      union: {
        desc: 'Union the lists in a list',
        help: 'Give a single param it unions all the lists in the list. Given two params it considers each a single list and unions the two together. So you can use it through pipes but also directly, which is nice. Respects keys if the first list has them, otherwise eats all keys.',
        params: [
          {
            key: 'value',
            desc: 'A list of lists to union',
            type: 'maybe-list'
          },
          {
            key: 'also',
            desc: 'A single list',
            type: 'maybe-list',
          },
        ],
        fun: function(value, also) {
          var hash = {}, used = [], stack, values
                    
          // TODO: remove this! hack!
          // if(value.length == 1 && value[0] == '') value = false
          
          if(!value && !also) return []
          else if(!value) values = also
          else if(also) values = [also, value]
          else values = DAML.toArray(value)
          
          if(Array.isArray(values[0])) return Array.prototype.concat.apply(Array.prototype, (this, values))
          
          // we have to do a fancy union that keeps nested keys intact...
          for(var i=0, l=values.length; i < l; i++) {
            value = values[i]
            for(var key in value) {
              if(used.indexOf(key) != -1) continue
              used.push(key)

              stack = []
              for(var j=0, k=values.length; j < k; j++) { // look through each key's value
                if(typeof values[j][key] != 'undefined') stack.push(values[j][key])
              }

              var temp = stack[stack.length - 1];
              if(typeof temp == 'number' || typeof temp == 'string') { // scalar
                hash[key] = temp
              } else if(DAML.isBlock(temp)) { // block
                hash[key] = temp
              } else { // list
                hash[key] = DAML.models.list.methods.union.fun(stack)
              }
            }
          }

          return hash
        },
      },
      
      // THINK: consider whether this could clobber variables passed in as values (do we need to deep clone?)  [nope!!]
      // TODO: ---> actually, only clone on entering and exiting variables, not between commands.
      
      rekey: {
        desc: 'Key the data by the path value',
        help: 'Note that like all list commands this returns the modified value, but does not change the input data. Without path it keys by consecutive integers. With stack it collects items into sublists.',
        params: [
          {
            key: 'value',
            desc: 'The data to rekey',
            type: 'list', // TODO: hash or list... what do we call that? [Just a list, thank you.]
            required: true,
          },
          {
            key: 'path',
            desc: 'A data path, like _id or my.user.group. Leave out to convert to list.',
            type: 'string',
            fallback: false,
          },
          {
            key: 'stack',
            desc: 'Returns a hash of lists of data items by stacking like-keyed items',
            type: 'string',
            fallback: false,
          },
        ],
        fun: function(data, path, stack) {
          var new_index, new_data = {}
          
          // TODO: allow rekeying by arbitrary daml, and remove stack param (it's effectively 'list group')
          // or... keep it. is it different? yes. kind of. no. maybe. erg. list some use cases...
          
          if(!path) return _.toArray(data)
          
          for(var index in data) {
            new_index = DAML.resolve_path(path, data[index])
            
            if(!stack) {
              new_data[new_index] = data[index]
            } 
            else {
              if(!new_data[new_index]) new_data[new_index] = []
              new_data[new_index].push(data[index])
            }
          }
          
          return new_data
        },
      },
      
      sort: {
        desc: 'Sort a list by something',
        help: 'Careful using this on keyed lists, as it currently eats keys.',
        params: [
          {
            key: 'value',
            desc: 'The list to reverse',
            type: 'list',
            required: true,
          },
          {
            key: 'by',
            desc: 'A string path',
            type: 'anything',
          },
        ],
        fun: function(value, by) {
          // TODO: # vs A-Z
          // TODO: allow 'by' to be a block, and run it as a sort function
          
          // var funk
          // 
          // if(typeof by == 'string') {
          //   funk = function(x) {
          //     return DAML.resolve_path(by, x)
          //   }
          // } 
          // else if(DAML.isBlock(by)) {
          //   funk = function(x) {
          //     DAML.import_var('this', x) // THINK: make this __this or something??? (allow user control via 'this' param)
          //     return by.toFun()() // TODO: fix this after changing blocks -- we can just do by.fun()
          //   }
          // }
          // else {
          //   funk = function(x) {return x}
          // }
          // 
          // // NOTE: we're creating an temp array of sortable values, sorting that array, then building a new array of the old values in the right order. mostly from https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort
          // 
          // var map = [] // temporary holder of position and sort-value
          // var result = [] // container for the resulting order
          // 
          // // walk original array to map values and positions
          // for(var i = value.length - 1; i >= 0; i--) {
          //   map.push({    
          //     index: i, // remember the index within the original array
          //     value: funk(value[i]) // evaluate the value to sort
          //   })
          // }
          // 
          // // sorting the map containing the reduced values
          // map.sort(function(a, b) {
          //   return a.value > b.value ? 1 : -1
          // })
          // 
          // // copy values in right order
          // for(var i=0, length = map.length; i < length; i++) {
          //   result.push(value[map[i].index])
          //   // THINK: could this eat supplied variables? maybe deep clone here...
          // }
          // 
          // return result
        },
      },
      
      range: {
        desc: 'Returns a range of numbers',
        params: [
          {
            key: 'length',
            desc: 'How many items to return',
            type: 'number',
            required: true,
          },
          {
            key: 'start',
            desc: 'Item to start with, inclusive',
            type: 'number',
            fallback: 1,
          },
          {
            key: 'step',
            desc: 'How many items to skip',
            type: 'number',
            fallback: 1,
          },
        ],
        fun: function(length, start, step) {
          var newlist = []
            , value = (start - step)
          
          if(length <= 0) 
            return DAML.onerror('The step must be positive');
          
          for(var i = 1; i <= length; i++) {
            value += step
            newlist.push(value)
          }
          
          return newlist
        },
      },
      
      reverse: {
        desc: 'Reverse a list',
        help: 'Careful using this on keyed lists, as it currently eats keys.',
        params: [
          {
            key: 'value',
            desc: 'The list to reverse',
            type: 'list',
            required: true,
          },
        ],
        fun: function(value) {
          var newlist = []
          for(var i = value.length - 1; i >= 0; i--) {
            newlist.push(value[i])
          }
          return newlist
        },
      },
      
      push: {
        desc: "Add a value to the end of a list",
        params: [
          {
            key: 'path',
            desc: 'A variable path, like :foo or :@foo.{#1}.baz',
            type: 'string'
          },
          {
            key: 'value',
            desc: 'Push this onto the end of the list',
            type: 'string'
          },
        ],
        fun: function(path, value) {
          
          // TODO: make this not change in-place -- all commands should change a copy
          // TODO: use 'data' as the primary parameter for operational data
          /*
            THINK: come up with language that distinguishes between lists, hashes, and *either* --> in DAML, a list and a hash are the *same* data object, which is just a mutable hash keyed by strings or consecutive integers or non-consecutive integers: we don't really care.
            In JS, the two fundamental data structures (lists and hashes) are optimized differently under the hood. We want to take advantage of that within the DAML core and handlers, while still respecting the fact that they're the same data structure in DAML. So every operation that takes a listhash has to handle it as either a list or a hash, whichever it maps to in JS. 
            It's really just a matter of a slight type mismatch between JS and DAML -- we just need good language to disambiguate. 'list' is nice, because it isn't used in JS proper, but it *really* implies an array and not a hash. 'hash' has the opposite problem.
            The DAML data structure is also *always* ordered, independent of keys, which is another difference.
            We could call it an 'association list', but: no good abbr., it's a concrete data structure (which we wouldn't use), it's not concise.
            'data'? container. 'stash? (for list-hash). stash is nice. it's a portmanteau. it means 'place to stick things'. it slightly implies array-like behavior, but that's compensated for by also being short for mustache. 
            
            WE'RE GOING TO STICK WITH 'LIST'. An indexed or keyed list is very similar to this data structure. 
            
          */
          
          // THINK: remap shortcuts for server vs client, e.g. 'log' could mean different things different places. This way you can still directly invoke the underlying command if you want that behavior, or use the shortcut for maximum flexibility. 
          
        },
      },
      
      extract: {
        desc: "Select some values from a list. Can reach inside sublists and pull pieces out.",
        help: "Without path it runs over the top level. Without daml it returns items from the path level. Without either it returns the input list.",
        params: [
          {
            key: 'value',
            desc: 'List to extract from',
            type: 'list',
            required: true,
          },
          {
            key: 'block',
            desc: "Sets '_this' and '_parent' (and '_parent.parent', and so on). Return true to nab it, false to leave it.",
            type: 'block',
          },
          {
            key: 'path',
            desc: 'A path for selecting sublists, like employees.office',
            type: 'string',
            fallback: '',
          },
        ],
        fun: function(value, block, path) {
          var result = []
          
          // DAML.recursive_path_walk(value, path, function(list, parent) {
          //   DAML.execute('variable', 'set', ['this', list])
          //   DAML.execute('variable', 'set', ['parent', parent])
          //   if(DAML.run(block)) result.push(list)
          // })
          
          return result
        },
      },
      
      // TODO: group, prune
      
    }
  }
})