// A list in DAML is an ordered sequence of items that are optionally keyed.

DAML.import_models({
  list: {
    desc: 'Commands for list manipulation',
    help: 'A list in DAML is an ordered sequence of items that are optionally keyed. Anything you can do with a classic list or hash you can do with a DAML list. It is the fundamental data structure in DAML.',
    methods: {
      
      map: {
        desc: 'Run DAML for each item, returning a list',
        params: [
          {
            key: 'data',
            desc: 'An array of data',
            type: 'list',
            required: true
          },
          {
            key: 'daml',
            desc: 'The daml to run',
            type: 'template',
            required: true
          },
        ],
        fun: function(data, daml) {
          var result = []
          
          // THINK: change 'value' to 'this'!!
          
          
          // TODO: add path param! easy changes to nested values!
          // TODO: add 'this' param (and 'key'?) to each of these.
          
          DAML.execute('variable', 'push_context')
          
          for(var i=0, l=data.length; i < l; i++) {
            DAML.execute('variable', 'set', ['key', i])
            DAML.execute('variable', 'set', ['value', data[i]]) // this bypasses the type system
            result.push(DAML.defunctionize(daml.toFun()))
          }

          DAML.execute('variable', 'pop_context')
          
          return result
        },
      },
      
      each: {
        desc: 'Run DAML for each item, returning a string',
        params: [
          {
            key: 'data',
            desc: 'An array of data',
            type: 'primitive',
            required: true
          },
          {
            key: 'daml',
            desc: 'The daml to run',
            type: 'template',
            required: true
          },
        ],
        fun: function(data, daml) {
          var output = ''
          
          DAML.execute('variable', 'push_context')
          
          for(var key in data) {
            DAML.execute('variable', 'set', ['key', key])
            DAML.execute('variable', 'set', ['value', data[key]]) // this bypasses the type system
            output += DAML.stringify(DAML.defunctionize(daml.toFun())) // do the defunc here, otherwise stringify does a fing check first. 
            // TODO: figure out a better way to design this...
          }

          DAML.execute('variable', 'pop_context')
          
          return output
        },
      },
      
      merge: {
        desc: "Merge data with a template, returning a string",
        params: [
          {
            key: 'data',
            desc: 'An array of data',
            type: 'primitive',
            required: true
          },
          {
            key: 'daml',
            desc: 'The daml to run',
            type: 'template',
            required: true
          },
        ],
        fun: function(data, daml) {
          var output = ''
          
          DAML.execute('variable', 'push_context')
          
          for(var outer_key in data) {
            var datum = data[outer_key]
            if(typeof datum != 'object') continue

            for(var inner_key in datum) {
              DAML.execute('variable', 'set', [inner_key, datum[inner_key]]) // NOTE: this bypasses the type system
            }
            
            output += DAML.stringify(DAML.defunctionize(daml.toFun())) // see above notes on defunc
          }

          DAML.execute('variable', 'pop_context')
          
          return output
        },
      },
      
      from_json: {
        desc: "Convert from a JSON string to a list",
        params: [
          {
            key: 'value',
            desc: 'The string to convert',
            type: 'string'
          }
        ],
        fun: function(value) {
          // TODO: wrap this in a try/catch!
          return JSON.parse(value)
        },
      },
      
      to_json: {
        desc: "Convert a list to a JSON string",
        params: [
          {
            key: 'value',
            desc: 'The list to convert',
            type: 'primitive'
          }
        ],
        fun: function(value) {
          return JSON.stringify(value)
        },
      },
      
      count: {
        desc: "Count the items in a list",
        params: [
          {
            key: 'value',
            desc: 'The list to count',
            type: 'list'
          }
        ],
        fun: function(value) {
          return value.length
        },
      },
      
      pair: {
        desc: "Create a new list, using the first item as its first key, the second item as that value, and so on.",
        params: [
          {
            key: 'value',
            desc: 'The list to convert',
            type: 'list'
          }
        ],
        fun: function(value) {
          var k, v, hash = {}
          
          if(value.length < 2) {            
            return DAML.setError('The value parameter must contain at least two elements')
          }

          // THINK: consider whether this could clobber variables passed in as values (do we need to deep clone?)

          while(value.length > 1) 
          {
            k = String(value.shift())
            v = value.shift()
            hash[k] = v
          }

          return hash
        },
      },
      
      union: {
        desc: "Union the lists in a list",
        params: [
          {
            key: 'values',
            desc: 'A list of lists to union',
            type: 'list' // TODO: LoL type
          },
        ],
        fun: function(value) {
          // THINK: consider whether this could clobber variables passed in as values (do we need to deep clone?)
          return _.union(value)
        },
      },
      
      rekey: {
        desc: 'Key the data by the path value',
        help: 'Note that like all list commands this returns the modified value, but does not change the input data. Without path it keys by consecutive integers. With stack it collects items into sublists.',
        params: [
          {
            key: 'value',
            desc: 'The data to rekey',
            type: 'hash', // TODO: hash or list... what do we call that? [Just a list, thank you.]
            required: true,
          },
          {
            key: 'path',
            desc: 'A data path, like _id or my.user.group. Leave out to convert to list.',
            type: 'string',
            fallback: false,
          },
          {
            key: 'stack',
            desc: 'Returns a hash of lists of data items by stacking like-keyed items',
            type: 'string',
            fallback: false,
          },
        ],
        fun: function(data, path, stack) {
          var new_index, new_data = {}
          
          if(!path) return _.toArray(data)
          
          for(var index in data) {
            new_index = DAML.resolve_path(path, data[index])
            
            if(!stack) {
              new_data[new_index] = data[index]
            } 
            else {
              if(!new_data[new_index]) new_data[new_index] = []
              new_data[new_index].push(data[index])
            }
          }
          
          return new_data
        },
      },
      
      sort: {
        desc: 'Sort a list by something',
        help: 'Careful using this on keyed lists, as it currently eats keys.',
        params: [
          {
            key: 'value',
            desc: 'The list to reverse',
            type: 'list',
            required: true,
          },
          {
            key: 'by',
            desc: 'A string path',
            type: 'anything',
          },
        ],
        fun: function(value, by) {
          // TODO: # vs A-Z
          // TODO: allow 'by' to be a fing, and run it as a sort function
          
          var funk
          
          if(typeof by == 'string') {
            funk = function(x) {
              return DAML.resolve_path(by, x)
            }
          } 
          else if(DAML.isFing(by)) {
            funk = function(x) {
              DAML.import_var('this', x) // THINK: make this __this or something??? (allow user control via 'this' param)
              return by.toFun()() // TODO: fix this after changing fings -- we can just do by.fun()
            }
          }
          else {
            funk = function(x) {return x}
          }
          
          // NOTE: we're creating an temp array of sortable values, sorting that array, then building a new array of the old values in the right order. mostly from https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort

          var map = [] // temporary holder of position and sort-value
          var result = [] // container for the resulting order

          // walk original array to map values and positions
          for(var i = value.length - 1; i >= 0; i--) {
            map.push({    
              index: i, // remember the index within the original array
              value: funk(value[i]) // evaluate the value to sort
            })
          }

          // sorting the map containing the reduced values
          map.sort(function(a, b) {
            return a.value > b.value ? 1 : -1
          })

          // copy values in right order
          for(var i=0, length = map.length; i < length; i++) {
            result.push(value[map[i].index])
            // THINK: could this eat supplied variables? maybe deep clone here...
          }

          return result
        },
      },
      
      reverse: {
        desc: 'Reverse a list',
        help: 'Careful using this on keyed lists, as it currently eats keys.',
        params: [
          {
            key: 'value',
            desc: 'The list to reverse',
            type: 'list',
            required: true,
          },
        ],
        fun: function(value) {
          var newlist = []
          for(var i = value.length - 1; i >= 0; i--) {
            newlist.push(value[i])
          }
          return newlist
        },
      },
      
      push: {
        desc: "Add a value to the end of a list",
        params: [
          {
            key: 'path',
            desc: 'A variable path, like :foo or :@foo.{#1}.baz',
            type: 'string'
          },
          {
            key: 'value',
            desc: 'Push this onto the end of the list',
            type: 'string'
          },
        ],
        fun: function(path, value) {
          
          // TODO: make this not change in-place -- all commands should change a copy
          // TODO: use 'data' as the primary parameter for operational data
          /*
            THINK: come up with language that distinguishes between lists, hashes, and *either* --> in DAML, a list and a hash are the *same* data object, which is just a mutable hash keyed by strings or consecutive integers or non-consecutive integers: we don't really care.
            In JS, the two fundamental data structures (lists and hashes) are optimized differently under the hood. We want to take advantage of that within the DAML core and handlers, while still respecting the fact that they're the same data structure in DAML. So every operation that takes a listhash has to handle it as either a list or a hash, whichever it maps to in JS. 
            It's really just a matter of a slight type mismatch between JS and DAML -- we just need good language to disambiguate. 'list' is nice, because it isn't used in JS proper, but it *really* implies an array and not a hash. 'hash' has the opposite problem.
            The DAML data structure is also *always* ordered, independent of keys, which is another difference.
            We could call it an 'association list', but: no good abbr., it's a concrete data structure (which we wouldn't use), it's not concise.
            'data'? container. 'stash? (for list-hash). stash is nice. it's a portmanteau. it means 'place to stick things'. it slightly implies array-like behavior, but that's compensated for by also being short for mustache. 
            
            WE'RE GOING TO STICK WITH 'LIST'. An indexed or keyed list is very similar to this data structure. 
            
          */
          
          // THINK: remap shortcuts for server vs client, e.g. 'log' could mean different things different places. This way you can still directly invoke the underlying command if you want that behavior, or use the shortcut for maximum flexibility. 
          
        },
      },
      
      extract: {
        desc: "Select some values from a list. Can reach inside sublists and pull pieces out.",
        help: "Without path it runs over the top level. Without daml it returns items from the path level. Without either it returns the input list.",
        params: [
          {
            key: 'value',
            desc: 'List to extract from',
            type: 'list',
            required: true,
          },
          {
            key: 'daml',
            desc: "Sets 'this' and 'parent' (and 'parent.parent', and so on). Return true to nab it, false to leave it.",
            type: 'template',
          },
          {
            key: 'path',
            desc: 'A path for selecting sublists, like employees.office',
            type: 'string',
            fallback: '',
          },
        ],
        fun: function(value, daml, path) {
          var result = []
          
          DAML.recursive_path_walk(value, path, function(list, parent) {
            DAML.execute('variable', 'set', ['this', list])
            DAML.execute('variable', 'set', ['parent', parent])
            if(DAML.run(daml)) result.push(list)
          })
          
          return result
        },
      },
      
      // TODO: group, prune
      
    }
  }
})