// commands for logic

DAML.import_models({
  logic: {
    desc: "Commands for logical reasoning",
    methods: {
      
      'if': {
        desc: 'Return the "then" param if "value" is true, else "else"',
        params: [
          {
            key: 'value',
            desc: 'True if it has elements or characters (empty strings and empty arrays are false, as is the number zero (but not the string "0"!))',
            required: true
          },
          {
            key: 'then',
            desc: 'Returned if value is true',
          },
          {
            key: 'else',
            desc: 'Returned if value is false'
          },
        ],
        fun: function(value, then, _else) {
          return DAML.ETC.is_false(value) ? _else : then
          
          // if(!value) return _else;
          // // if(!DAML.isNice(value)) return _else;
          // // if(value === 0 || value === '') return _else;
          // if(typeof value == 'object' && _.isEmpty(value)) return _else;
          // 
          // return then;
        },
      },
      
      'is': {
        desc: 'If value is in in or like like, return true',
        params: [
          {
            key: 'value',
            desc: 'Value to compare',
            required: true
          },
          {
            key: 'in',
            desc: 'Array of potential matches',
            type: 'list'
          },
          {
            key: 'like',
            desc: 'A string for exact matches -- wrap with / / for regular expression matching',
            type: 'string'
          },
        ],
        fun: function(value, _in, like) {
          if(!DAML.isNice(like)) {
            if(DAML.isNice(_in)) return _in.indexOf(value) !== -1
            
            if(!_.isArray(value)) return DAML.onerror("Requires 'in', 'like', or a value list")
            
            var base = value[0] // test each item
            for(var i=1, l=value.length; i < l; i++) {
              if(!this.methods.is.fun(base, null, value[i])) return false;
            }
            return true;
          }
          
          // TODO: make a new 'logic equal' command, that takes a list or two args. then make 'is like' only for regex?
          
          
          if(like[0] !== '/' || !DAML.ETC.flag_checker_regex.test(like)) {
            return value == like // exact match, ish.
          }
          
          like = DAML.ETC.string_to_regex(like)
          return like.test(value)
        },
      },
      
      'cond': {
        desc: 'Given a list of lists, test the first element and run the remainder if true, stopping after the first',
        params: [
          {
            key: 'value',
            desc: 'A list of lists, or a single list with alternating tests and expressions',
            type: 'rawlist',
            required: true
          }
        ],
        fun: function(value) {
          var unwrapped = _.find(value, function(item) {
            return (typeof item != 'object' || DAML.isFing(item))
          })
          
          if(unwrapped) {
            var new_value = []
            for(var i=0, l=value.length; i < l; i += 2) {
              new_value.push([value[i], value[i+1]])
            }
            value = new_value
          }
          
          for(var i=0, l=value.length; i < l; i++) {
            var test = DAML.run(value[i][0])
            if(test) {
              for(var j=1, l=value[i].length; j < l; j++) {
                test = DAML.run(value[i][j])
              }
              return test
            }
          }
          
          return false
        },
      },
      
      'switch': {
        desc: 'Given a value, find a matching expression',
        params: [
          {
            key: 'on',
            desc: 'The value to switch on',
            type: 'primitive',
            required: true
          },
          {
            key: 'value',
            desc: 'A list of value then expression then value then expression and so on and so forth and etcetera and yada yada',
            type: 'rawlist',
            required: true
          }
        ],
        fun: function(on, value) {
          for(var i=0, l=value.length; i < l; i = i + 2) {
            var test = DAML.run(value[i])
            if(test == on) {
              return value[i+1]
            }
          }
          
          return false
        },
      },
      
      and: {
        desc: "If all values are true, return true",
        params: [
          {
            key: 'value',
            desc: 'A set of values to check for falsiness (runs all incoming templates, no short-circuiting)',
            type: 'list',
            required: true,
          },
          {
            key: 'also',
            desc: 'Some other values (checked first)',
            type: 'primitive',
          },
        ],
        fun: function(value, also) {
          if(typeof also != 'undefined') {
            return !!value && !!also
          }
          
          for(var key in value) {
            if(!value[key]) return false
          }
          
          return true
        },
      },
      
      or: {
        desc: "Accepts a list of values or two separate values; runs all incoming templates, no short-circuiting",
        help: "Note that the 'first' param is considered before the 'value' param, if it is included. This makes the examples easier to read.",
        examples: [
          '{5 | or 10}',
          '{false | or :true}',
          '{(false 1 2 3) | or}',
          '{or (false 1 2 3)}',
          '{(false 0 "") | or :true}',
        ],
        params: [
          {
            key: 'value',
            desc: 'Some values to check for truthiness',
            type: 'primitive',
            required: true,
          },
          {
            key: 'also',
            desc: 'Some other values (checked first)',
            type: 'primitive',
          },
        ],
        fun: function(value, also) {
          if(also) return also
          
          if(typeof also != 'undefined') return value

          for(var key in value) {
            if(value[key]) return value[key]
          }
          
          return false
        },
      },
      
      not: {
        desc: "Returns the opposite of value",
        params: [
          {
            key: 'value',
            desc: 'A value whose value to reverse value',
            required: true,
          },
        ],
        fun: function(value) {
          return DAML.ETC.is_false(value) ? true : false
          
          // TODO: make this a core DAML method!
          // if(!value) return true;
          // if(typeof value == 'object' && _.isEmpty(value)) return true;
          // 
          // return false;
        },
      },
      
    }
  }
})