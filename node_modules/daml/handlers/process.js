// commands for processing DAML

DAML.import_models({
  process: {
    desc: "Commands for processing DAML in various interesting ways",
    vars: {},
    methods: {
      
      // THINK: we should have another function like the pipe that takes a list of commands to run in parallel...
      
      pipe: {
        desc: "Execute a pipeline",
        params: [
          {
            key: 'value',
            desc: 'A list of DAML commands',
            type: 'rawlist',
            required: true
          },
        ],
        fun: function(value) {
          var output, pipeval;

          // store old pipe value
          pipeval = DAML.VARS['__'];
          DAML.VARS['__'] = undefined;
          
          for(var i=0, l=value.length; i < l; i++) {
            output = DAML.fun_run(value[i]);
            
            // set pipe value
            if(i != l-1) {
              DAML.execute('variable', 'set', ['__', output]);
            }
          }

          // restore old pipe value
          DAML.execute('variable', 'set', ['__', pipeval]); // we have to use {var set}, otherwise the Vstack gets corrupted.

          return output;
        },
      },
      
      
      map: {
        desc: 'Run DAML for each item, returning a list',
        params: [
          {
            key: 'data',
            desc: 'An array of data',
            type: 'list',
            required: true
          },
          {
            key: 'template',
            desc: 'The daml to run',
            type: 'template',
            required: true
          },
        ],
        fun: function(data, template) {
          var result = [];
          
          // TODO: add 'this' param (and 'key'?) to each of these.
          
          DAML.execute('variable', 'push_context');
          
          for(var i=0, l=data.length; i < l; i++) {
            DAML.execute('variable', 'set', ['key', i]);
            DAML.execute('variable', 'set', ['value', data[i]]); // this bypasses the type system
            result.push(DAML.defunctionize(template.toFun()));
          }

          DAML.execute('variable', 'pop_context');
          
          return result;
        },
      },
      
      each: {
        desc: 'Run DAML for each item, returning a string',
        params: [
          {
            key: 'data',
            desc: 'An array of data',
            type: 'primitive',
            required: true
          },
          {
            key: 'template',
            desc: 'The daml to run',
            type: 'template',
            required: true
          },
        ],
        fun: function(data, template) {
          var output = '';
          
          DAML.execute('variable', 'push_context');
          
          for(var key in data) {
            DAML.execute('variable', 'set', ['key', key]);
            DAML.execute('variable', 'set', ['value', data[key]]); // this bypasses the type system
            output += DAML.stringify(DAML.defunctionize(template.toFun())); // do the defunc here, otherwise stringify does a fing check first. 
            // TODO: figure out a better way to design this...
          };

          DAML.execute('variable', 'pop_context');
          
          return output;
        },
      },
      
      merge: {
        desc: "Merge data with a template, returning a string",
        params: [
          {
            key: 'data',
            desc: 'An array of data',
            type: 'primitive',
            required: true
          },
          {
            key: 'template',
            desc: 'The daml to run',
            type: 'template',
            required: true
          },
        ],
        fun: function(data, template) {
          var output = '';
          
          DAML.execute('variable', 'push_context');
          
          for(var outer_key in data) {
            var datum = data[outer_key];
            if(typeof datum != 'object') continue;

            for(var inner_key in datum) {
              DAML.execute('variable', 'set', [inner_key, datum[inner_key]]); // NOTE: this bypasses the type system
            }
            
            output += DAML.stringify(DAML.defunctionize(template.toFun())); // see above notes on defunc
          }

          DAML.execute('variable', 'pop_context');
          
          return output;
        },
      },
      
      // send: {
      //   desc: "Send something back to the server or whatever",
      //   help: "This breaks out of the temporal flow. It's good for events and DOM manipulation, but might wreak havoc with templates and REPL.",
      //   params: [
      //     {
      //       key: 'daml',
      //       desc: 'A command to send',
      //       type: 'template',
      //       required: true
      //     },
      //     {
      //       key: 'then',
      //       desc: "Something to do after. Data is pushed into 'this'",
      //       type: 'template',
      //     },
      //   ],
      //   fun: function(daml, then) {
      //     jDaimio.process(
      //       daml.toString(), 
      //       function(data, response, vars) {
      //         DAML.import_var('this', data);
      //         DAML.run(then);
      //       }
      //     );
      //   },
      // },
      
      wait: {
        desc: "Wait for for time or until all until commands finish",
        help: "This breaks out of the temporal flow. It's good for events and DOM manipulation, but might wreak havoc with templates and REPL.",
        params: [
          {
            key: 'for',
            desc: 'A number of milliseconds to wait',
            type: 'number',
          },
          {
            key: 'until',
            desc: "An array of commands to process in parallel",
            type: 'template',
          },
          {
            key: 'then',
            desc: "Something to do after. Data from until is pushed into 'this'",
            type: 'template',
          },
        ],
        fun: function(_for, until, then) {
          if(DAML.isNice(_for)) {
            setTimeout(function() {DAML.run(then)}, _for); // make this include the until stuff too
          }
        },
      },
      
      
      
      log: {
        desc: "Push something into the log",
        params: [
          {
            key: 'value',
            desc: 'A string or object to log',
            type: 'anything',
            required: true
          },
          {
            key: 'passthru',
            desc: 'If true, return the value'
          },
        ],
        fun: function(value, passthru) {
          // TODO: make this work server-side also (maybe a call to DAML, with split client/server libs)
          
          // THINK: we should defunc things, or something, probably... maybe like this?
          value = (typeof value === 'function') ? value() : value;
          
          console.log(value);
          
          if(passthru) return value;
        },
      },
      
    }
  }
});