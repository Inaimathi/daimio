// commands for processing DAML

DAML.import_models({
  process: {
    desc: "Commands for processing DAML in various interesting ways",
    vars: {},
    methods: {
      
      // THINK: we should have another function like the pipe that takes a list of commands to run in parallel...
      
      pipe: {
        desc: "Execute a pipeline",
        params: [
          {
            key: 'value',
            desc: 'A list of DAML commands',
            type: 'rawlist',
            required: true
          },
        ],
        fun: function(value) {
          var output, pipeval;

          // store old pipe value
          pipeval = DAML.VARS['__'];
          DAML.VARS['__'] = undefined;
          
          for(var i=0, l=value.length; i < l; i++) {
            output = DAML.fun_run(value[i]);
            
            // set pipe value
            if(i != l-1) {
              DAML.execute('variable', 'set', ['__', output]);
            }
          }

          // restore old pipe value
          DAML.execute('variable', 'set', ['__', pipeval]); // we have to use {var set}, otherwise the Vstack gets corrupted.

          return output;
        },
      },
      
      // send: {
      //   desc: "Send something back to the server or whatever",
      //   help: "This breaks out of the temporal flow. It's good for events and DOM manipulation, but might wreak havoc with templates and REPL.",
      //   params: [
      //     {
      //       key: 'daml',
      //       desc: 'A command to send',
      //       type: 'template',
      //       required: true
      //     },
      //     {
      //       key: 'then',
      //       desc: "Something to do after. Data is pushed into 'this'",
      //       type: 'template',
      //     },
      //   ],
      //   fun: function(daml, then) {
      //     jDaimio.process(
      //       daml.toString(), 
      //       function(data, response, vars) {
      //         DAML.import_var('this', data);
      //         DAML.run(then);
      //       }
      //     );
      //   },
      // },
      
      wait: {
        desc: "Wait for for time or until all until commands finish",
        help: "This breaks out of the temporal flow. It's good for events and DOM manipulation, but might wreak havoc with templates and REPL.",
        params: [
          {
            key: 'for',
            desc: 'A number of milliseconds to wait',
            type: 'number',
          },
          {
            key: 'until',
            desc: "An array of commands to process in parallel",
            type: 'template',
          },
          {
            key: 'then',
            desc: "Something to do after. Data from until is pushed into 'this'",
            type: 'template',
          },
        ],
        fun: function(_for, until, then) {
          if(DAML.isNice(_for)) {
            setTimeout(function() {DAML.run(then)}, _for); // make this include the until stuff too
          }
        },
      },
      
      // THINK: a command that lets you pass a handler, method, and hash o' params, for those fancy occasions. 
      
      log: {
        desc: "Push something into the log",
        params: [
          {
            key: 'value',
            desc: 'A string or object to log',
            type: 'anything',
            required: true
          },
          {
            key: 'passthru',
            desc: 'If true, return the value'
          },
        ],
        fun: function(value, passthru) {
          // TODO: make this work server-side also (maybe a call to DAML, with split client/server libs)
          
          // THINK: we should defunc things, or something, probably... maybe like this?
          value = (typeof value === 'function') ? value() : value;
          
          console.log(value);
          
          if(passthru) return value;
        },
      },
      
    }
  }
});