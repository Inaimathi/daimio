// A space contains mutable state (variables) and serializes processing. Use channels to pass information between spaces.

DAML.import_models({
  space: {
    desc: 'Commands for spacial manipulation',
    methods: {
      
      add: {
        desc: 'Add a new space',
        params: [
          { key: 'name'
          , desc: 'The name for the space -- currently needs to be unique systemwide'
          , type: 'string'
          , required: true
          }
        , { key: 'dialect'
          , desc: 'I have no idea how this will work'
          , type: 'string'
          }
        , { key: 'block'
          , desc: 'Some code that runs when the space is "activated", whatever that means'
          , type: 'string' // TODO: this is stupid
          // , type: 'block'
          }
        ],
        fun: function(name, dialect, block) {
          dialect = DAML.DIALECTS.top // TODO: what should this be?
          
          block = DAML.Parser.string_to_block_segment(block)
          
          if(DAML.SPACES[name])
            return DAML.setError('That space has already been added')
          
          DAML.SPACES[name] = new DAML.Space(dialect, block)
          
          // THINK: how do we constrain which spaces have access to this gateway??
          return name
        },
      },
      
      send: {
        desc: "Send a message directly to a space",
        params: [
          {
            key: 'name',
            desc: 'A space name',
            type: 'string',
            required: true
          },
          {
            key: 'value',
            desc: 'A value to send',
            type: 'anything',
            required: true
          },
        ],
        fun: function(name, value, callback) {
          var space = DAML.SPACES[name]
          
          if(!space)
            return DAML.setError('That is not a valid space')
          
          space.deliver(value, callback)
          
          return NaN
        },
      },
      
    }
  }
})