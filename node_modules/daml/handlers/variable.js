// commands for variables

DAML.import_models({
  variable: {
    desc: "Commands for variable manipulation",
    vars: {counter: 0, paths: [], bindings: {}, bindhashes: {}, activepaths: {}},
    methods: {
      
      get: {
        desc: "Get a variable value",
        params: [
          {
            key: 'path',
            desc: 'A variable path, like :foo or :@foo.#1.{:bat}.*.baz',
            type: 'string',
            required: true,
            falsy: false,
          },
          // scope: {
          //   // THINK: is this useful?
          //   desc: 'A particular context scope to search within',
          //   type: 'string',
          // },
        ],
        fun: function(path) {   // , scope
          var variables, output;
          
          if(this.vars.paths.indexOf(path) != -1) return false;
          
          if(/^(@.+|[A-Z]+)$/.test(path.split('.', 1)[0])) {
            // variables = DAML.Vglobals; // @ and uppercase vars are global (UC vars are read-only)
          } else {
            // if(scope) {
            //   variables = _.find(DAML.Vstack, function(context) {return context.key == scope}); // fixed scope
            // } else {
              variables = DAML.VARS; // regular vars
            // }
          }
          
          this.vars.paths.push(path); // prevents 'poison pipe' infinite recursion, where the function representing {variable get path "__"} is set as the value of {__}. (it happens surprisingly often, indirectly.)
          
          output = DAML.resolve_path(path, variables);
          
          this.vars.paths.pop();
          
          return output;
        },

      },
      
      set: {
        desc: 'Set a variable value',
        params: [
          {
            key: 'path',
            desc: 'A variable path, like :foo or :@foo.{:asdf}.baz',
            type: 'string',
            required: true,
            falsy: false,
          },
          {
            key: 'value',
            desc: 'A new value',
            type: 'anything'
          },
          // scope: {
          //   desc: 'A particular context scope to search within',
          //   type: 'string',
          // }
        ],
        fun: function(path, value) {  // , scope
          var words, variables, pathobj, tempobj;
          
          // THINK: we deep copy objects on the way in, so we don't A) tweak other variables by reference and B) leak out of DAML into the base language by accident, but it's kind of slow.
          
          if(path.indexOf('{') != -1) {
            path = DAML.run(path);
          }
          
          words = path.split('.');
          // value = DAML.toPrimitive(value); // THINK: setting this kills a few tests, but prevents nasty recursion from i.e. {(__) | string join}, which puts the {var get path __} function into an array and then calls it after the pipe with predictably disastrous results. 

          // TODO: make this WORMy
          // if(!uppercase_override && /^[A-Z]+$/.test(words[0])) { // both uppercase and only letters (no # or _ or $ or @)
          //   return DAML.setError('Uppercase globals are read-only');
          // }
          
          // pathobj = value;
          // for(var i = words.length - 1; i >= 0; i--) {
          //   tempobj = {};
          //   tempobj[words[i]] = pathobj;
          //   pathobj = tempobj; // {words[i]: pathobj}; 
          // }
          
          /*
            Thoughts on vars:
            - CAPS vars are write-once (immutable)
            - go back to block scope
            - use caution with @vars (top scope)
            - once declared, always scoped at that level (simpler, no hiding) [merge destruction?]
            - mirror objects magically bridge the daml world and the mundane world [top level, global, Firstcap, flagged as magical, handled outside this system so as not to trigger bindings when set from inside]
          */
          
          
          if(path[0] == '@' || /^[A-Z]+$/.test(words[0])) {
            // variables = DAML.Vglobals; // @ vars are global
            DAML.recursive_insert(variables, words, value);
          } else {
            // if(!DAML.Vstack.length) {DAML.execute('variable', 'push_context');} // shouldn't ever happen
            variables = DAML.Vstack[DAML.Vstack.length - 1]; // regular vars
            if(words.length == 1) {
              variables[path] = value;
              DAML.VARS[path] = value;
            } else {
              // TODO: this isn't quite right -- should find the nearest Vstack that has the root var, or pick the last Vstack if none, and then copy root value from Vstack into VARS
              DAML.recursive_insert(variables, words, value);
              DAML.recursive_insert(DAML.VARS, path.split('.'), value); // THINK: words is empty here. what's a more natural way of doing this?            
            }
          }
          
          var return_value = DAML.deep_copy(value);
          var bindings = this.vars.bindings[path];
          if(bindings && !this.vars.activepaths[path]) {
            this.vars.activepaths[path] = true;
            for(var i=0, l=bindings.length; i < l; i++) {
              // if the value's an object we need to deep copy it here, so we can pass the original value in as __var and return it into the pipeline.
              var safe_value = DAML.deep_copy(return_value);
              
              // DAML.execute('variable', 'push_context');
              // THINK: popping context here destroys our ability to affect (non-pre-existing) local vars. but setting __ directly might affect things also. (what things?)
              DAML.Vstack[DAML.Vstack.length - 1]['__var'] = safe_value;
              DAML.VARS['__var'] = safe_value;
              bindings[i](); // we set __ for each, so they always take the same value (even if the variable itself is edited by earlier bindings)
              // DAML.execute('variable', 'pop_context');
            }
            this.vars.activepaths[path] = false;
          }
          
          return return_value;
        },
      },
      
      push_context: {
        desc: "Put a new context on the stack",
        // params: {
        //   key: {
        //     desc: 'A word for the stack',
        //     type: 'string'
        //   }
        // },
        // fun: function(key) {
        //   if(typeof key != 'string' || !/^\w+$/.test(key)) {
        //     key = 'auto' + ++this.vars.counter; // THINK: maybe remove key along with the named context code
        //   }
        //   DAML.Vstack.push({key: key, values: {}});
        params: [
          {
            key: 'passthru',
            desc: 'A value to pass through the pipeline'
          }
        ],
        fun: function(passthru) {
          DAML.Vstack.push({});
          return passthru;
        },
      },
      
      pop_context: {
        desc: "Take a context off the stack",
        params: [
          {
            key: 'passthru',
            desc: 'A value to pass through the pipeline'
          }
        ],
        fun: function(passthru) {
          if(!DAML.Vstack.length) return DAML.setError('At end of stack');
          // TODO: mutate VARS
          var found, vstack = DAML.Vstack.pop();
          _.each(vstack, function(value, key) {
            found = false;
            // NOTE: dot-path references (like foo.baz.car) are added to the most local stack that has a matching top-level var (like foo). when that stack goes away, so do those dot-paths. so pay attention.
            for(var i = DAML.Vstack.length - 1; i >= 0; i--) {
              if(DAML.Vstack[i][key]) {
                DAML.VARS[key] = DAML.Vstack[i][key];
                found = true;
                break;
              }
            }
            if(!found) delete DAML.VARS[key];
          });
          
          return passthru;
        },
      },
      
      bind: {
        desc: "Bind a DAML action to a variable",
        params: [
          {
            key: 'path',
            desc: "The variable name",
            type: 'string',
            required: true,
            falsy: false,
          },
          {
            key: 'daml',
            desc: "A DAML string",
            type: 'block',
            required: true,
          },
        ],
        fun: function(path, daml) {
          var b = this.vars.bindings;
          
          b[path] = [daml]
          // if(!b[path]) {
          //   b[path] = [daml.toFun()];
          // } else {
          //   b[path].push(daml.toFun());
          // }
          
          // TODO: allow 'wildcard' variable bindings, like 'foo.x.*' which would match 'foo.x', 'foo.x.y', 'foo.x.y.z' etc
          
          this.vars.bindhashes[daml.hash] = b[path].length - 1; // for unbinding
          this.vars.activepaths[path] = false; // for recursion prevention
        },
      },
      
      unbind: {
        desc: "Remove an action from a variable's binding",
        params: [
          {
            key: 'path',
            desc: "The variable name",
            type: 'string',
            required: true,
            falsy: false,
          },
          {
            key: 'daml',
            desc: "The exact DAML string used for binding",
            type: 'block',
            required: true,
          },
        ],
        fun: function(path, daml) {
          var bh = this.vars.bindhashes;
          
          // TODO: binding the same daml to multiple variables will kill this, because it's not path-based.
          
          if(!bh[daml.hash] && bh[daml.hash] !== 0) return DAML.onerror('That daml template is not currently bound');
          this.vars.bindings[path].splice(bh[daml.hash], 1);
        },
      },
      
    }
  }
});