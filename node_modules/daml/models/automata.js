// general commands for general things

DAML.import_models({
  automata: {
    desc: "Basic Katsu commands",
    methods: {
      
      // A 'cell' is a square on the playboard. {x: x, y: y, slices: cell_obj}...
      
      go: {
        desc: "Applies automata rules to some things",
        params: [
          {
            key: 'key',
            desc: "A template key for new things",
            type: "string",
            required: true,
          },
          {
            key: 'rules',
            desc: "An ordered pair of numbers, like ((2 3) (4 5 6 7))",
            fallback: [[3,4],[3,4]],
            type: "list",
            required: true,
          },
          {
            key: 'food',
            desc: "A string of letters required to survive (none for normal automata)",
            type: "string"
          },
          {
            key: 'poison',
            desc: "A string of instakill letters (none for normal automata)",
            type: "string"
          },
        ],
        fun: function(key, rules, food, poison) {
          var birth_rule, keep_rule, slices, checked = {},
              mychar = '', mod_x, mod_y, index, count, cell, data, fcount, pcount,
              things = Katsu.find_things(null, key),
              last = Katsu.swears.playboard,
              template = Katsu.templates[key],
              max_x = Katsu.swears.max_x,
              max_y = Katsu.swears.max_y;

          food = food ? new RegExp('[' + DAML.ETC.regex_escape(food) + ']') : false;
          poison = poison ? new RegExp('[' + DAML.ETC.regex_escape(poison) + ']') : false;


          // THINK: maybe we can make a cache of the board for each template, and update the nine neighbors every time a thing is spawned or destroyed. then we already have counts of neighbors, so we only need to go through each item once. food and poison make this weird, though.

          // THINK: do we need an array of 'good' chars in addition to food and poison? 
          
          if(_.isEmpty(things)) return false;
          if(!template) return false;
          
          mychar = template['data'];

          birth_rule = rules[0];
          keep_rule = rules[1];

          for(var key in things) {
            var thing = things[key];
            
            // check our eight neighbors
            for(var dy = -1; dy <= 1; dy++) {
              mod_y = thing.y + dy;
              if(mod_y < 0) {mod_y = max_y;} // y is zero
              if(mod_y > max_y) {mod_y = 0;} // y is max
              
              for(var dx = -1; dx <= 1; dx++) {
                mod_x = thing.x + dx;
                if(mod_x < 0) {mod_x = max_x;} // x is zero
                if(mod_x > max_x) {mod_x = 0;} // x is max

                // coords = Katsu.torus_coords(mod_x, mod_y, max_x, max_y);
                // mod_x = coords[0];
                // mod_y = coords[1];

                index = mod_x + '_' + mod_y;
                if(checked[index] || checked[index] === 0) continue; // checked it already
                
                cell = last[mod_y][mod_x];
                if((dy || dx) && cell.data.length) continue; // it's either one of us or something else.
                
                count = count_neighbors(mod_x, mod_y, last, checked, food, poison, max_x, max_y, mychar);
                
                if(cell.data.indexOf(mychar) !== -1) { // one of us
                  if(keep_rule.indexOf(count) == -1) { // bad count
                    cell.layers[cell.data.indexOf(mychar)].obj.destroy();
                  }
                } else {
                  if(!cell.data.length && birth_rule.indexOf(count) != -1) { // empty square [THINK: overwriting?]
                    Katsu.Thing.spawn(template, mod_x, mod_y);
                  }
                } 
              }
            }
            
            // // have I been checked already?
            // index = thing.x + '-' + thing.y;
            // if(checked[index] !== undefined) return true; // checked ourselves already
            // 
            // // sup?
            // count = count_neighbors(thing.x, thing.y);
            // if(death_rule.indexOf(count) == -1) thing.destroy();
          }
        },
      }
      
    }
  }
});

count_neighbors = function(x, y, last, checked, food, poison, max_x, max_y, mychar) {
  var fcount = 0, pcount=0, count = 0;
  var index = x + '_' + y;
  if(checked[index] || checked[index] === 0) return checked[index];
  
  for(var dy = -1; dy <= 1; dy++) {
    var mod_y = y + dy;
    if(mod_y < 0) {mod_y = max_y;} // y is zero
    if(mod_y > max_y) {mod_y = 0;} // y is max
    
    for(var dx = -1; dx <= 1; dx++) {
      var mod_x = x + dx;
      if(mod_x < 0) {mod_x = max_x;} // x is zero
      if(mod_x > max_x) {mod_x = 0;} // x is max

      // coords = Katsu.torus_coords(mod_x, mod_y, max_x, max_y);
      // mod_x = coords[0];
      // mod_y = coords[1];
      
      // OPT: this is the slow part, down here:
      var data = last[mod_y][mod_x].data.join('');
      if(!data) continue;
      if(data.indexOf(mychar) !== -1) count++;
      if(food && food.test(data)) fcount++;
      if(poison && poison.test(data)) pcount++;
    } 
  }
  
  if(food && !fcount) count = 0;
  if(poison && pcount) count = 0;
  checked[index] = count;
  // return 4;
  // return 3; 
  return count;
};
