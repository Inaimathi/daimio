// commands for engaging with things

DAML.import_models({
  thing: {
    desc: "Methods for engaging things",
    methods: {
      
      find: {
        desc: "Find a set of things -- currently 'or'ing all attribute values",
        params: [
          {
            key: 'by_ids',
            desc: "A set of thing ids",
          },
          {
            key: 'by_types',
            desc: "A set of thing types, like 'wall' or 'enemy'",
          },
          {
            key: 'by_attrs',
            desc: "A map of attribute->value",
          },
        ],
        fun: function(by_ids, by_types, by_attrs) {
          return Katsu.find_things(by_ids, by_types, by_attrs);
        },
      },
      
      activate: {
        desc: "Run on.tick for a set of things",
        params: [
          {
            key: 'for',
            desc: "Things (leave empty for everything)",
            type: "list",
            // required: true,
          },
        ],
        fun: function(_for) {
          var thing, things;
          
          if(_for.length && _.first(_for).key) {
            things = _for;
          } else {
            things = Katsu.find_things();
          }
          
          DAML.execute('variable', 'push_context');
          
          // OPT: make an ontick_cache here, a map from template -> !!on.tick
          
          for(var key in things) {
            thing = things[key];
            if(!Katsu.templates[thing.template].on.tick) return false;
            DAML.import_var('this', thing);
            thing.ontick();
          }
          DAML.execute('variable', 'pop_context');
        },
      },
      
      spawn: {
        desc: "Create a new thing",
        params: [
          {
            key: 'template',
            desc: "A thing template to spawn",
            fallback: "antispore",
            type: "string",
            required: true,
          },
          {
            key: 'x',
            desc: "Starting x coordinate",
            fallback: "0",
            type: "number",
            required: true,
          },
          {
            key: 'y',
            desc: "Starting y coordinate",
            fallback: "0",
            type: "number",
            required: true,
          },
          {
            key: 'direction',
            desc: "An allowable direction, like 'se' or 'n'.",
            fallback: "",
            type: "string", // TODO: make a direction type
          },
        ],
        fun: function(template, x, y, direction) {
          var thing, dir = Katsu.compass[direction];
          
          if(dir) {
            x += dir[0];
            y += dir[1];
          }

          // TODO: store this shot delay routine elsewhere (in the shot DAML?)
          // if(this.thing.lasttick + 3 > Katsu.swears.tickcount) {return true;}
          // this.thing.lasttick = Katsu.swears.tickcount;

          // oy.
          coords = Katsu.torus_coords(x, y, Katsu.swears.max_x, Katsu.swears.max_y);
          x = coords[0]; 
          y = coords[1];

          thing = Katsu.Thing.spawn(template, x, y);
          
          // TODO: move this vector setting into the DAML
          // THINK: why do we need both of these?
          if(thing && dir) {
            thing.attrs.vector = dir;
            thing.attrs.direction = direction;
            // x += dir[0];
            // y += dir[1];
          }
        },
      },
      
      translate: {
        desc: "Translate the thing one unit",
        params: [
          {
            key: 'id',
            desc: "The thing id",
            fallback: "1",
            type: "number",
            required: true,
          },
          {
            key: 'direction',
            desc: "An allowable direction, like 'se' or 'n'.",
            fallback: "n",
            type: "string", // upgrade to 'direction' later, or something... [nwse]{1,2}
            required: true,
          },
        ],
        fun: function(id, direction) {
          var coords, thing, x, y, dir;

          if(thing = Katsu.things[id]) {
            if(dir = Katsu.compass[direction]) {
              coords = Katsu.torus_coords(dir[0] + thing.x, dir[1] + thing.y, Katsu.swears.max_x, Katsu.swears.max_y);
              thing.translate(coords[0] - thing.x, coords[1] - thing.y);
            }

            // TODO: move this into its own method
            // if(thing.attrs.facing && thing.attrs.facing[this.settings.direction]) {
            //   thing.attrs.sprite = thing.attrs.facing[this.settings.direction];
            // }

            return id;
          }
        },
      },
      
      set_attribute: {
        desc: "Set a single attribute on a thing",
        params: [
          {
            key: 'id',
            desc: "The thing id",
            fallback: "1",
            type: "number",
            required: true,
          },
          {
            key: 'attribute',
            desc: "An attribute name",
            type: "string",
            required: true,
          },
          {
            key: 'value',
            desc: "The desired value",
            fallback: "",
          },
        ],
        fun: function(id, attribute, value) {
          
          // THINK: is this a, uh, a good thing? it seems pretty sneaky...
          // DAML.run('{thing find by_ids :34115320 | __.#1 | > :this || 123 | > :this.attrs.foo | this}')
          
          var thing = Katsu.things[id];
          if(thing) {
            thing.attrs[attribute] = value;
            // TODO: enhance to accept a full path
          } else {
            return console.log('invalid thing');
          }
        },
      },
      
      set_data: {
        desc: "Set the thing's data",
        params: [
          {
            key: 'id',
            desc: "The thing id",
            fallback: "1",
            type: "number",
            required: true,
          },
          {
            key: 'data',
            desc: "The data",
          },
        ],
        fun: function(id, data) {
          var thing = Katsu.things[id];
          if(thing) {
            Katsu.layers[thing.id].set_data(data);
          } else {
            return console.log('Invalid thing');
          }
        },
      },
            
      vector_move: {
        desc: "Move a thing by its vector attribute",
        params: [
          {
            key: 'id',
            desc: "The thing id",
            type: "number",
            required: true,
          },
        ],
        fun: function(id) {
          var thing = Katsu.things[id];
          if(!thing) {return false;}

          var coords, 
              dir = thing.attrs.vector;

          if(dir) {
            coords = Katsu.torus_coords(dir[0] + thing.x, dir[1] + thing.y, Katsu.swears.max_x, Katsu.swears.max_y);
            thing.translate(coords[0] - thing.x, coords[1] - thing.y);
          }

          return id;
        },
      },
      
      teleport: {
        desc: "Move a thing to the given coordinates",
        help: "Note that this currently ignores all collision conditions.",  
        params: [
          {
            key: 'id',
            desc: "The thing id",
            type: "number",
            required: true,
          },
          {
            key: 'x',
            desc: "The X factor",
            type: "number"
          },
          {
            key: 'y',
            desc: "The Y factor",
            type: "number"
          },
        ],
        fun: function(id, x, y) {
          var thing = Katsu.things[id];
          if(!thing) {return false;}

          if(!x) x = 0;
          if(!y) y = 0;
          
          // THINK: torus_coords?
          
          Katsu.layers[thing.id].raw_move(x, y);
          
          return id;
        },
      },
      
      destroy: {
        desc: "Destroy a thing immediately",
        params: [
          {
            key: 'id',
            desc: "The thing id",
            fallback: "1",
            type: 'number',
            required: true,
          },
        ],
        fun: function(id) {
          var thing = Katsu.things[id];
          if(thing) {
            thing.destroy();
          } else {
            return console.log('Invalid thing');
          }
        },
      },
      
    },
  },
});

