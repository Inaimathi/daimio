<!DOCTYPE html> 
<html> 
<head> 
  <title>Daimio Tests</title>
  <script type="text/javascript" src="../get.php?file=daimio&x=1"></script>
  <style type="text/css" media="screen">
    code {
      color: #00F;
    }
    .good {
      background-color: #EFE;
    }
    .bad {
      background-color: #FEE;
    }
    .actual {
      color: #F00;
      background-color: #FEE;
    }
  </style>

  <script type="text/javascript" charset="utf-8">
    // load daimio file
    function xhr_get(target, callback) {
      var xhr = new XMLHttpRequest()
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          callback(xhr.responseText)
        }
      }
      xhr.open('GET', target, true)
      xhr.send(null)
    }
    
    xhr_get('daimio.dm', function(data) {
      // these globals are kind of a hack...
      lines = data.split(/\n/).reverse()
      starttime = new Date().getTime()
      win=0
      lose=0
      html=''
      mode='text'
      block_name=''
      code_value=''
      code_string=''
      
      D.dataTrampoline(lines, eat_line, D.string_concat, function() {}, done)
    })

    function eat_line(value, prior_starter) {
      var whitespace='', wscount=0
        , line = lines.pop()
        
      /*
        There's four modes:
        - text, which just displays regular text based on whitespace and other factors
        - code, which is a single line of code
        - block, which is a big block of code
        - assert, the value the code should process to
      */
      
      // mode switcher
      if(mode != 'block') {
        if(/^\s*\{begin /.test(line)) {
          code_string = ''
          block_name = line.match(/^\s*\{begin (\w+)/)[1]
          mode = 'block' // begin a block
        } 
        else if(mode == 'code') {
          mode = 'assert' // switch to assert
        }
        else if(/^\s*\{/.test(line)) {
          code_string = line
          mode = 'code' // begin a line of code
        } 
        else if(mode == 'assert') {
          mode = 'text' // switch back to text
        }
      }
      
      // continue the block
      if(mode == 'block') {
        code_string += "\n" + line

        // end the block
        if(new RegExp("\{end " + block_name + '\}').test(line)) {
          mode = 'code'
        }
      }
      
      // sort out whitespace
      whitespace = ''
      wscount = line.search(/\S/)
      if(wscount >= 1) {
        whitespace = new Array( wscount + 1 ).join( '&nbsp;' )
        // whitespace = line.slice(0, wscount !== -1).replace(/\s/, '&nbsp;&nbsp;')
      }
      
      // handle text
      if(mode == 'text') {
        html += '<p class="ws' + wscount + '">' + whitespace + line + '</p>'
      }
      
      // handle code
      if(mode == 'code') {
        html += '<code><pre>' + code_string + '</pre></code>'
        
        code_string = code_string.replace(/^\s+|\s+$/g, '')
        
        code_value = D.execute_then_stringify(
                       D.ExecutionSpace.execute(
                         D.Parser.string_to_block_segment(code_string), null, prior_starter))
        return code_value
      }
      
      // handle asserts
      if(mode == 'assert') {
        if(code_value === false) {
          code_value = ''
        }
        
        if(typeof(code_value) != 'string') {
          code_value = JSON.stringify(code_value) ? JSON.stringify(code_value) : ''
        }
        
        if(code_value.trim() === line.trim()) {
          result = 'good'
          win++
        } else {
          result = 'bad'
          lose++
        }
        
        // TODO: convert line and code_value to escaped html
        
        html += '<pre class="assert ' + result + '">' + line + '</pre>'
        if(result == 'bad') {
          html += '<pre class="actual">Actual: ' + code_value + '</pre>'
        }
      }
      
      return true
    }
    
    function done() {
      var endtime = new Date().getTime()

      stats = "<p>Completed " + (win + lose) + " tests in " + ((endtime - starttime) / 1000) + " seconds.</p>"
      stats += '<p><span class="good">Won ' + win + ' tests.</span></p>'
      
      if(lose) stats += '<p><span class="bad">Lost ' + lose + ' tests.</span></p>'
      if(!lose) stats += '<p>You win!!!</p>'
      
      document.getElementById('stats').innerHTML = stats
      document.getElementById('tests').innerHTML = html
    }
    
  </script>
  
</head>
<body id="">  
  <form style="width: 99%; position: fixed; top: 0px; margin: 0px">
    <textarea id="code" name="code" rows="1">Try me out! Type something up here!</textarea>
    <div id="history"></div>
  </form>
  
  <p>&nbsp;</p>
  
  <div id="stats"></div>
  
  <div id="tests"></div>
  
  
  <script>
    // NOTE: this has to be set before emmet is loaded
    emmetKeymap = {
  		'Ctrl-E': 'expand_abbreviation',
  		'Shift-Ctrl-D': 'match_pair_outward',
    }
  </script>

  <link rel="stylesheet" href="../codemirror/lib/codemirror.css">
  <script src="../codemirror/lib/codemirror.js"></script>
  <script src="../codemirror/mode/daimio/daimio.js"></script>
  
  <link rel="stylesheet" href="../codemirror/addon/hint/show-hint.css">
  <script src="../codemirror/addon/hint/show-hint.js"></script>
  <script src="../codemirror/addon/hint/daimio-hint.js"></script>
  
  <script src="../codemirror/addon/emmet/emmet.js"></script>
    
  <script>
    var ge = document.getElementById.bind(document)
      , results = ge('results')
      , history = ge('history')
      , repl = CodeMirror.fromTextArea(ge('code'), {})
      , ac_on = true
      , background = '#f8f8f8'
    
    CodeMirror.commands.autocomplete = function(instance) {
      CodeMirror.showHint(instance, CodeMirror.hint.daimio, {
        extraKeys: {'Space': function(instance, hint) {hint.pick()}}
      , completeSingle: false
      , closeCharacters: /[\n|"]/
      })
    }
    
    repl.setOption('extraKeys', {
      "Esc": function(instance) {
        ac_on = !ac_on
        // show whether a/c is on
        repl.display.wrapper.style.backgroundColor = ac_on ? background : 'pink'
      },
      "Enter": function(instance, x, y, z) {
        repl_display(instance.getLine(0))
        instance.setLine(0, '{')
      }
    })
    repl.setOption('lineNumbers', false)
    repl.setOption('matchBrackets', true)
    repl.display.wrapper.style.backgroundColor = background
        

    repl.on("change", function(instance, change) {
      // if(change.removed[0] && !change.text[0])
      //   return true
      
      // if(last_char != '{' && old_last_char != ' ' && old_last_char.length == 1)
      //   return true
      
      if(ac_on)
        CodeMirror.commands.autocomplete(instance)

      return false
    })
      

    repl.on("beforeChange", function(instance, change) {
      // remove pasted newlines
      if(/\n/.test(change.text)) {
        var newtext = change.text.join("").replace(/\n/g, "")
        change.update(change.from, change.to, [newtext])
        return true
      }
      
      // add space to changes caused by autocomplete
      if(change.from.constructor != CodeMirror.Pos && !change.origin) {
        change.update(change.from, change.to, [change.text[0] + " "])
        return true
      }
    })
    
    repl_display = function(code) {
      // history.innerHTML += '<p class="good">' + code + '</p>'
      // history.innerHTML += '<p class="bad">' + D.run(code) + '</p>'

      console.log(code)
      D.run(code)
      
      // D.run(code.value, function(result) {
      //   results.innerHTML = result
      // })
      
    }

    // from http://stackoverflow.com/questions/13026285/codemirror-for-just-one-line-textfield
    repl.setSize("100%", repl.defaultTextHeight() + 8) // 8 for font


// NOTE: saving the following lines in case they're needed later -- delete this if you haven't had any scrollbar issues, otherwise change these to repl.display.foo references
//    cm.on("change", function(instance, change) {
//      document.querySelector(".CodeMirror-hscrollbar").style.display = 'none'
//    });
//    document.querySelector(".CodeMirror-scroll").style.overflow = 'hidden'

  </script>
</body>
</html>