<!DOCTYPE html> 
<html> 
<head> 
  <title>Daimio Tests</title>
  
  <script type="text/javascript" src="../get.php?file=node_modules/daimio&x=1"></script>
  
  <style type="text/css" media="screen">
    code {
      color: #00F;
    }
    .good {
      background-color: #EFE;
    }
    .bad {
      background-color: #FEE;
    }
    .actual {
      color: #F00;
      background-color: #FEE;
    }
  </style>

  <script type="text/javascript" charset="utf-8">
    // load daimio file
    $.get('daimio.dm', function(data) {
      
      // these globals are kind of a hack...
      lines = data.split(/\n/).reverse()
      starttime = new Date().getTime()
      win=0
      lose=0
      html=''
      mode='text'
      block_name=''
      code_value=''
      code_string=''
      
      D.dataTrampoline(lines, eat_line, D.string_concat, function() {}, done)
      // eat_lines()
    })
    
    // eat_lines = function(value) {
    //   var output = false
    //   
    //   if(value !== undefined) {
    //     code_value = value
    //   }
    //   
    //   while(lines.length) {
    //     output = eat_line()
    //     if(output !== output) return false
    //   }
    // 
    //   done()
    // }
    
    function eat_line(value, prior_starter) {
      var whitespace='', wscount=0
        , line = lines.pop()
        
      /*
        There's four modes:
        - text, which just displays regular text based on whitespace and other factors
        - code, which is a single line of code
        - block, which is a big block of code
        - assert, the value the code should process to
      */
      
      // mode switcher
      if(mode != 'block') {
        if(/^\s*\{begin /.test(line)) {
          code_string = ''
          block_name = line.match(/^\s*\{begin (\w+)/)[1]
          mode = 'block' // begin a block
        } 
        else if(mode == 'code') {
          mode = 'assert' // switch to assert
        }
        else if(/^\s*\{/.test(line)) {
          code_string = line
          mode = 'code' // begin a line of code
        } 
        else if(mode == 'assert') {
          mode = 'text' // switch back to text
        }
      }
      
      // continue the block
      if(mode == 'block') {
        code_string += "\n" + line

        // end the block
        if(new RegExp("\{end " + block_name + '\}').test(line)) {
          mode = 'code'
        }
      }
      
      // sort out whitespace
      whitespace = ''
      wscount = line.search(/\S/)
      if(wscount >= 1) {
        whitespace = new Array( wscount + 1 ).join( '&nbsp;' )
        // whitespace = line.slice(0, wscount !== -1).replace(/\s/, '&nbsp;&nbsp;')
      }
      
      // handle text
      if(mode == 'text') {
        html += '<p class="ws' + wscount + '">' + whitespace + line + '</p>'
      }
      
      // handle code
      if(mode == 'code') {
        html += '<code><pre>' + code_string + '</pre></code>'
        // var callback = function(value) {
        //   eat_lines(value)
        // }
        // D.run(code_string, callback)
        // return NaN // signal of callback
        
        code_string = code_string.replace(/^\s+|\s+$/g, '')
        
        code_value = D.execute_then_stringify(D.ExecutionSpace.execute(D.Parser.string_to_block_segment(code_string), null, prior_starter))
        return code_value
      }
      
      // handle asserts
      if(mode == 'assert') {
        if(code_value === false) {
          code_value = ''
        }
        
        if(typeof(code_value) != 'string') {
          code_value = JSON.stringify(code_value) ? JSON.stringify(code_value) : ''
        }
        
        if(code_value.trim() === line.trim()) {
          result = 'good'
          win++
        } else {
          result = 'bad'
          lose++
        }
        
        // TODO: convert line and code_value to escaped html
        
        html += '<pre class="assert ' + result + '">' + line + '</pre>'
        if(result == 'bad') {
          html += '<pre class="actual">Actual: ' + code_value + '</pre>'
        }
      }
      
      return true
    }
    
    function done() {
      var endtime = new Date().getTime()

      stats = "<p>Completed " + (win + lose) + " tests in " + ((endtime - starttime) / 1000) + " seconds.</p>"
      stats += '<p><span class="good">Won ' + win + ' tests.</span></p>'
      
      if(lose) stats += '<p><span class="bad">Lost ' + lose + ' tests.</span></p>'
      if(!lose) stats += '<p>You win!!!</p>'
      
      $('#stats').html(stats)
      $('#tests').html(html)
    }
    
    
  </script>
  
</head>
<body id="">  
  <div id="stats"></div>
  
  <div id="tests"></div>
  
  <form style="width: 99%; position: fixed; bottom: 0px; margin: 0px"><textarea id="code" name="code" rows="1"></textarea></form>
  
  <script>
    // NOTE: this has to be set before emmet is loaded
    emmetKeymap = {
  		'Ctrl-E': 'expand_abbreviation',
  		'Shift-Ctrl-D': 'match_pair_outward',
    }
  </script>

  <link rel="stylesheet" href="../codemirror/lib/codemirror.css">
  <script src="../codemirror/lib/codemirror.js"></script>
  <script src="../codemirror/mode/daimio/daimio.js"></script>
  
  <link rel="stylesheet" href="../codemirror/addon/hint/show-hint.css">
  <script src="../codemirror/addon/hint/show-hint.js"></script>
  <script src="../codemirror/addon/hint/daimio-hint.js"></script>
  
  <script src="../codemirror/addon/emmet/emmet.js"></script>
    
  <script>
    var gid = document.getElementById.bind(document)
      , results = gid('results')
      , code = gid('code')
      , editor = CodeMirror.fromTextArea(code, {})
    
    CodeMirror.commands.autocomplete = function(cm) {
      CodeMirror.showHint(cm, CodeMirror.hint.daimio, {
        extraKeys: {'Space': function(cm, hint) {hint.pick()}}
      , completeSingle: true
      })
    }
    
    editor.setOption('extraKeys', {
      "Esc": "autocomplete",
      "Enter": function(instance, x, y, z) {
        cmi_display(instance.getLine(0))
        instance.setLine(0, '')
      }
    })
    editor.setOption('lineNumbers', true)
    editor.setOption('matchBrackets', true)
    
    D.run(code.value, function(result) {
      results.innerHTML = result
    })
    
    // gogogadget oneline cm
    var cm = editor
      
    // from http://stackoverflow.com/questions/13026285/codemirror-for-just-one-line-textfield
    cm.setSize("100%", cm.defaultTextHeight() + 2 * 4)
    // 200 is the preferable width of text field in pixels,
    // 4 is default CM padding (which depends on the theme you're using)

    // now disallow adding newlines in the following simple way
    cm.on("beforeChange", function(instance, change) {
      var newtext = change.text.join("").replace(/\n/g, "") // remove ALL \n !
      change.update(change.from, change.to, [newtext])
      return true
    })
    
    cmi_display = function(code) {
      console.log(code)
      D.run(code)
    }

    // and then hide ugly horizontal scrollbar
    cm.on("change", function(instance, change) {
        $(".CodeMirror-hscrollbar").css('display', 'none');
        // (!) this code is using jQuery and the selector is quite imperfect if
        // you're using more than one CodeMirror on your page. you're free to
        // change it appealing to your page structure.
    });

    // the following line fixes a bug I've encountered in CodeMirror 3.1
    $(".CodeMirror-scroll").css('overflow', 'hidden');
    // jQuery again! be careful with selector or move this to .css file

  </script>
  
</body>
</html>